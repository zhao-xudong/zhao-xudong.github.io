<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaFX程序的基本结构]]></title>
    <url>%2F2018%2F05%2F12%2FJavaFX%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[JavaFX程序的基本结构 MyJavaFX.java： 1234567891011121314151617import javafx.application.Application;import javafx.stage.Stage;import javafx.scene.control.*;import javafx.scene.*;public class MyJavaFX extends Application&#123; @Override public void start(Stage primaryStage)&#123; Button btOK=new Button(&quot;ok&quot;); Scene scene=new Scene(BUtton,200,250); primaryStage.setTitle(&quot;辣鸡&quot;); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args)&#123; Application.launch(args); &#125;&#125; 运行结果： 程序解析： ​ launch方法是一个定义在Application类中的静态方法，用于启动一个独立的JavaFX应用。 ​ 主类重写了定义在javafx.application.Application类中的start方法。当一个JavaFX应用启动时，JVM使用它的无参构造方法来创建类的一个实例，同时调用其start方法。start方法一般用于将UI组件放入一个场景，并在舞台中显示该场景。 ​ 一个Scene对象可以使用构造方法Scene(node,width,height)创建，这个构造方法指定了场景的宽度和高度，并将节点置于一个场景中。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaFX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python糗百爬虫]]></title>
    <url>%2F2018%2F05%2F10%2FPython%E7%B3%97%E7%99%BE%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Python糗百爬虫 12345678910111213141516171819202122# -*- coding:utf-8 -*-import urllib2import urllibimport reurl=&apos;https://www.qiushibaike.com/8hr/page/1/&apos;headers=&#123;&apos;User-Agent&apos; : &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos;&#125;try: request=urllib2.Request(url,headers=headers) response=urllib2.urlopen(request) content=response.read().decode(&apos;utf-8&apos;) pattern=re.compile(&apos;&lt;div class=&quot;author.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&apos;+&apos;&lt;div class=&quot;content&quot;&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&apos;+&apos;&lt;i class=&quot;number.*?&gt;(.*?)&lt;/i&gt;(.*?)&lt;/span&gt;.*?&apos;,re.S) items=re.findall(pattern,content) for item in items: print item[0],item[1],item[2],item[3]except urllib2.URLError,e: if hasattr(e,&quot;code&quot;): print e.code if hasattr(e,&quot;reason&quot;): print e.reason 爬取结果：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习地址]]></title>
    <url>%2F2018%2F05%2F10%2FPython%E5%AD%A6%E4%B9%A0%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[Python学习地址 廖雪峰的Python基础知识 崔庆才的Python爬虫学习]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门级爬取百度百科词条]]></title>
    <url>%2F2018%2F05%2F10%2FPython%E5%85%A5%E9%97%A8%E7%BA%A7%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%E8%AF%8D%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[Python入门级爬取百度百科词条 目标爬取 Angelababy词条历史版本 中的value值。 尝试爬取网页123456789101112131415# _*_ coding:utf-8 _*_import urllibimport urllib2import repage = 1url = &apos;https://baike.baidu.com/historylist/Angelababy/1509275#page&apos;+str(page)try: request = urllib2.Request(url) response = urllib2.urlopen(request) print response.read()except urllib2.URLError, e: if hasattr(e,&quot;code&quot;): print e.code if hasattr(e,&quot;reason&quot;): print e.reason 运行结果： 可以看到已经爬取了此网页所有的内容。现在需要实现的就是爬取想要的value值了。 爬取目标内容 可以看到要爬取的内容，格式全部一样都是图中所示，代码如下： 12345678&lt;tr&gt; &lt;td class=&quot;checkBox&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;128140635&quot;&gt; &lt;/td&gt; . . .&lt;/tr&gt; 所以我们做以下正则匹配： 1pattern = re.compile(&apos;&lt;tr&gt;.*?&lt;td class=&quot;checkBox&quot;&gt;.*?&lt;input.*?value=&quot;(.*?)&quot;&gt;.*?&lt;/td&gt;.*?&lt;/tr&gt;&apos;,re.S) 全部代码如下： 12345678910111213141516171819# _*_ coding:utf-8 _*_import urllibimport urllib2import repage = 1url = &apos;https://baike.baidu.com/historylist/Angelababy/1509275#page&apos;+str(page)try: request = urllib2.Request(url) response = urllib2.urlopen(request) content = response.read().decode(&apos;utf-8&apos;) pattern = re.compile(&apos;&lt;tr&gt;.*?&lt;td class=&quot;checkBox&quot;&gt;.*?&lt;input.*?value=&quot;(.*?)&quot;&gt;.*?&lt;/td&gt;.*?&lt;/tr&gt;&apos;,re.S) items = re.findall(pattern,content) for item in items: print(item)except urllib2.URLError,e: if hasattr(e,&quot;code&quot;): print e.code if hasattr(e,&quot;reason&quot;): print e.reason 爬取结果如下： 学习链接崔庆才的个人博客]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>百科词条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鲜衣怒马，归来不再少年]]></title>
    <url>%2F2018%2F04%2F29%2F%E9%B2%9C%E8%A1%A3%E6%80%92%E9%A9%AC%EF%BC%8C%E5%BD%92%E6%9D%A5%E4%B8%8D%E5%86%8D%E5%B0%91%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[鲜衣怒马，归来不在少年 ​ 周末总是孤独的，想要找些什么填充自己，划着优酷，划到了《前任3》，于是… … ​ 空间里有朋友在刷屏，好像是失恋了，不知道发生了什么。想起了前几天手机崩溃，相册被清空的事，后怕的打开了相册。第一张是在学四公寓拍的一张照片，当时很非，便做了很久的头像，那是一本我从来没有读过的屠格涅夫散文集，现在翻起来却又是另一番味道，让人沉迷。 ​ ​ 翻到了两年前的自拍，比现在瘦比现在阳光。翻到了学生会的合影，灯光很暖，翻到了烫头的照片，或许以前的肆无忌惮也只有回忆了，时间总是向前走的，回忆也无法回到过去。年少轻狂，满纸荒唐。曾经不是一个人，便天不怕地不怕，颇有挥斥方遒，意气风发。回过头来，其实也只是一段梦，梦的很真实，梦的很开心。梦总是要醒来的，毕竟生活还是要继续的。人会变，生活也会变，生活越来越喜欢与你独处，喜欢看你迷茫的样子，喜欢你拿起酒杯的样子。 ​ 看到这张图的时候，不知道自己在想什么，只是觉得很舒服，好像什么都放下了一样。我收到了肯定，不艰辛的不是成长，熬过苦难便是收获，每一个看到她的人都露出了微笑。自己选择的路，终归要走下去，对于新鲜的事物也有一定保质期，我感觉自己的审美疲劳到来了。得得失失，失失得得，终归要结束这宴席，毕竟我一定不是适合这场游戏的。生活吗，尤其是要走向成年人的生活，哈哈哈哈泡枸杞喝热水，终归要失去点什么、看透点什么、学会点什么或许还能带进土里。 ​ ​ 有些照片、有些话语我会好好的保存下来，它常常能带给我开心，像是冬日透过云彩的阳光散落在身上，温暖着丝丝凉意。等到我再次翻阅的时候，我会感觉到可笑、幼稚，那时候我应该是已经忘记了那种感觉，无法再构建起那份回忆，我希望我不会删除它们。 ​ 鲜衣怒马，归来…… ​ 不在少年。]]></content>
      <categories>
        <category>生活小调</category>
      </categories>
      <tags>
        <tag>negative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[社会再叛逆，也要做社会主义接班人]]></title>
    <url>%2F2018%2F04%2F26%2F%E7%A4%BE%E4%BC%9A%E5%86%8D%E5%8F%9B%E9%80%86%EF%BC%8C%E4%B9%9F%E8%A6%81%E5%81%9A%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%8E%A5%E7%8F%AD%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[社会再叛逆，也要做社会主义接班人 ​ 时2018年4月24日，去往颐和园的公交上。 ​ 车走过两站，终于有一个空座，于是就坐了下来，刷刷知乎，回回消息。车又过了一站，上来了一家人（爷爷奶奶带着小孙子），上车后售票员开始说希望坐老弱病残座儿的给小孩子让座之类的话，然而大家都在低头刷手机并没有要让座的意思，小孩子的奶奶上来以后并没有喊着售票员要给小孙子找座，而是拉紧小孙子想让他坐在车座旁边的地方（在我认为，这就是一种很有素质的行为，而且脑子里都是孩子）。我习惯给老人孕妇孩子让座，于是我（蓝座）就招呼着让她们坐下来，这位奶奶一边安置着小孙子，一边跟我说谢谢，并且让小孙子说“谢谢叔叔”，小孙子很乖，也对我说了。说真的，这一刻我真的感慨这位奶奶的教育，这肯定不是这一刻才教育出来的。当然写这些并不是要表现我自己有多么高大上，站在道德制高点批评别人，而是对成长的疑惑，困扰了我很久的疑惑。 ​ 我很难预测未来的我是什么职业、什么性格、什么价值观。但是我从小被中华美德教育熏陶，并努力追求现如今的社会主义价值观。我会去尊重每一位值得我尊敬的人，我会对说清洁阿姨说谢谢，会对服务生说谢谢，会对每一位“卑微”职业的人说谢谢；我会对我的老师说谢谢，对同学说谢谢，会对每一位帮助过我的人说谢谢；我觉得这是尊重别人的基本，也是对自己的尊重。我会拧紧每一个水龙头，我会将电池扔到该扔的地方，我觉得我应该为保护地球做出一点贡献。我会给小孩、老人和孕妇让座，我会对服务生说“我自己来”，我会去农民工子弟学校面对叽叽喳喳的学生进行支教，我觉得这是我应该做的。 ​ 我曾看到过很多人忽略，或许长大让他们变得很忙碌，每天踩着快节奏的鼓点奔波忙碌，忙到没有意识没有精力打理这种小事，忘了说一声谢谢；或许他们累了，累到已经无法再去让座了；或许生活让他们心情有些难过，只能独善其身。 ​ 我也曾看到很多人背道而驰，不仅对类似的事嗤之以鼻，甚至对”施善者“打压构建和谐友爱社会的积极性，在他邻域的人会因为他的话他的行为开始不去做这些事，或许这就是社会的叛逆。 ​ 成功者的路是孤独的。成功者的标新立异才造就孤独吧。我不想在后辈的语文课上没有了中华美德熏陶，我相信哪怕我温暖了一个人，也会温暖我整个世界。 ​ 我不知道未来的自己是什么样的，我害怕以后的我是现在的我所不喜欢的、是陌生的。那么，在现在的年纪，希望自己依旧跟随自己的内心做一些心中的小善，哪怕未来的自己是那么陌生、可恶，当我望向台灯的时候，我会记得我曾经努力的在做社会主义的接班人。]]></content>
      <categories>
        <category>生活小调</category>
      </categories>
      <tags>
        <tag>禅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Font类]]></title>
    <url>%2F2018%2F04%2F22%2FFont%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Font类 要点提示：Font类描述字体名、粗细和大小。 ​ 可以砸渲染文字的时候设置字体信息。javafx.scene.text.Font类用于创建字体。 ​ Font实例可以使用它的构造方法或者静态方法来创建。Font可以用它的名字、字体粗细、字体形态和大小来描述。Times、Courier和Arial是字体名字的实例。可以通过调用静态方法getFamilies()获得一个可用的字体系列名字列表。List是一个为列表字体通过方法的接口。ArrayList是List的一个具体实现。字体形态是两个常量：FontPosture.IRALIC和FontPosture.REGULAR。例如下面的语句生成两个字体。 12Font font1 = new Font(&quot;SansSerif&quot;,16);//字体(SansSerif，大小16)Font font2 = Font.font(&quot;Times New Roman&quot;,FontPosture.IRALC,FontPosture.REGULAR,20);//字体(Times New Roman、加粗、斜体和大小为20) javafx.scene.text.Font -size: double //该字体的大小 -name: String //该字体的名字 -family: String //该字体属于的字体集 +Font(size: double) //使用给定字体大小创建一个Font +Font(name: String,size: double)//使用给定的字体完整名称和大小创建一个Font +font(name: String,size: double)//使用给定的字体名称和大小创建一个Font +font(name: String,w: FontWeight,size: double)//使用给定的字体名称、粗细和大小创建一个Font +font(name: String,w: FontWeight,p:FontPosture,size: double)//使用给定的字体名称、粗细、字形以及大小创建一个Font +getFamilies(): List //返回一个字体集名字的列表 +getFontName(): List //返回一个字体完整名称的列表，包括字体集和粗细 12345678910111213141516171819202122232425262728293031323334package ohhh;import javafx.application.Application;import javafx.scene.Scene;import javafx.scene.layout.*;import javafx.scene.paint.Color;import javafx.scene.shape.Circle;import javafx.scene.text.*;import javafx.scene.control.*;import javafx.stage.Stage;public class FontDemo extends Application&#123; @Override public void start(Stage primaryStage)&#123; Pane pane = new StackPane(); Circle circle = new Circle(); circle.setRadius(50); circle.setStroke(Color.BLACK); circle.setFill(new Color(0.5,0.5,0.5,0.1)); pane.getChildren().add(circle); Label label = new Label(&quot;JavaFX&quot;); label.setFont(Font.font(&quot;Times New Roman&quot;,FontWeight.BOLD,FontPosture.ITALIC,20)); pane.getChildren().add(label); Scene scene=new Scene(pane); primaryStage.setTitle(&quot;FontDemo&quot;); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args)&#123; Application.launch(args); &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaFX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList类]]></title>
    <url>%2F2018%2F04%2F22%2FArrayList%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[ArrayList类 java.util.ArrayList +ArrayList() //返回一个空的列表 +add(o:E): void //添加一个新元素o到列表末尾 +add(index: int,o: E): void //添加一个新元素o到该列表的指定下标位置 +clear(): void //清除列表所有元素 +contains(o: Object) //如果该列表有o，返回true +get(index: int): E //返回该列表指定下标位置的元素 +indexOf(o: Object): int //返回列表中第一个匹配元素的下标 +isEmpty(): boolean //如果该列表不包括任何元素，返回true +lastIndexOf(o: Object): int //返回列表中匹配的最后一个元素的下标 +remove(o: Object): boolean //去除列表的第一个元素，如果该元素被去除，则返回true +size(): int //返回列表中元素个数 +remove(index: int): E //去除指定下标位置的元素，如果该元素被去除，则返回true set(index: int,o: E): E //设置指定下标位置的元素 程序清单：TestArrayList.java 123456789101112131415161718192021222324252627282930package ohhh;import java.util.ArrayList;public class TestArrayList &#123;public static void main(String[] args)&#123; ArrayList&lt;String&gt; cityList = new ArrayList&lt;&gt;(); cityList.add(&quot;London&quot;);//添加London cityList.add(&quot;Denver&quot;);//添加Denver cityList.add(&quot;Paris&quot;);//添加Paris cityList.add(&quot;Miami&quot;);//添加Miami cityList.add(&quot;Seoul&quot;);//添加Seoul cityList.add(&quot;Tokyo&quot;);//添加Tokyo System.out.println(&quot;List size? &quot;+cityList.size());//列表元素数 System.out.println(&quot;Is Miami in the list? &quot;+cityList.contains(&quot;Miami&quot;));//是否有Miami System.out.println(&quot;The location of Denver in the list? &quot;+cityList.indexOf(&quot;Denver&quot;));//Denver的下标 System.out.println(&quot;Is the list empty? &quot;+cityList.isEmpty());//列表是否为空 cityList.add(2, &quot;Xian&quot;);//下标为2添加Xian cityList.remove(&quot;remove&quot;);//抹除 cityList.remove(1);//抹除下标为1的 System.out.println(cityList.toString());//输出cityList列表 for(int i=cityList.size()-1;i&gt;=0;i--) System.out.print(cityList.get(i));//输出列表里的所有元素 System.out.println(); ArrayList&lt;CircleFromSimpleGeometricObject&gt; list= new ArrayList&lt;&gt;(); list.add(new CircleFromSimpleGeometricObject(2)); list.add(new CircleFromSimpleGeometricObject(3)); System.out.println(&quot;The area of the first circle? &quot;+list.get(0).getArea());&#125;&#125; 输出结果： 1234567List size? 6Is Miami in the list? trueThe location of Denver in the list? 1Is the list empty? false[London, Xian, Paris, Miami, Seoul, Tokyo]TokyoSeoulMiamiParisXianLondonThe area of the first circle? 0.0 对列表有用的方法 Array类中的静态方法asList返回一个列表，该列表传递给ArrayList的构造方法用于创建一个ArrayList。 12String[] array = &#123;&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;&#125;;ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(Array.asList(array)); 反过来也可以使用list.toArray(array1)从数组列表创建一个对象数组 12String[] array1 = new String[list.size()];list.toArray(array1); 如果列表中的元素是可比较的，比如整数、双精度浮点数或者字符串 ，则可以使用java.util.Collections类中的静态方法sort方法来对元素进行排序。 1234Integer[] array = &#123;3,5,95,4,15,34,3,6,5&#125;;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Array.asList(array));java.util.Collections(list);System.out.println(list); 可以使用java.util.Collections类中的静态的max和min方法来返回列表中的最大和最小元素。 1234Integer[] array = &#123;3,5,95,4,15,34,3,6,5&#125;;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Array.asList(array));System.out.println(java.util.Collections.max(list));System.out.println(java.util.Collections.min(list)); 可以使用java.util.Collections类中的静态方法shuffle方法来随机打乱列表的元素。 1234Integer[] array = &#123;3,5,95,4,15,34,3,6,5&#125;;ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Array.asList(array));java.util.Collection.shuffle(list);System.out.println(list); 完结。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态绑定]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[动态绑定要点提示：方法可以沿着继承链的多个类中实现。JVM决定运行时调用哪个方法。 ​ 方法可以在父类中定义而在子类中重写。例如：toString()方法在Object类中定义的，而在GeometricObject类中重写。思考下面代码： 12Object o =new GeometricObject();System.out.println(o.toString()); ​ 这里的o调用哪个toString()呢？为了回答这个问题，我们首先介绍两个术语：声明类型和实际类型。一个变量必须被声明为某种类型。变量的这个类型成为它的声明类型（declared type）。这里，o的声明类型是Object。一个引用类型变量可以是一个null值或者一个对声明类型实例的引用。实例可以使用声明类型或它的子类型的构造方法创建。变量的实际类型（actual type）是被变量引用的对象的实际类。这里，o的实际类型是GeometricObject,因为o指向使用new GeometricObject()创建的对象。o调用哪个toString()方法由o的实际类型决定。这成为动态绑定。 ​ 动态绑定的工作机制如下：假设对象o是类C1，C2，….，Cn的实例，其中C1是C2的子类，C2是C3的子类…Cn-1是Cn的子类，也就是说Cn是最通用类，C1是最特殊的类。在Java中，Cn是Object类。如果对象o调用一个方法p，那么JVM会依次在类C1，C2，….，Cn-1，Cn中查找方法p的实现，直到找到为止。一旦找到就实现，就停止查找，然后使用首先找到的实现。 DynamicBindingDemo.java 12345678910111213141516171819202122232425262728package ohhh;public class DynamicBindingDemo&#123; public static void main(String[] args)&#123; m(new GraduateStudent()); m(new Student()); m(new Person()); m(new Object()); &#125; public static void m(Object x)&#123; System.out.println(x.toString()); &#125; public static class GraduateStudent extends Student&#123; &#125; public static class Student extends Person&#123; @Override public String toString()&#123; return &quot;Student&quot;; &#125; &#125; public static class Person extends Object&#123; @Override public String toString()&#123; return &quot;Person&quot;; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给自己的博客加上图片]]></title>
    <url>%2F2018%2F04%2F19%2F%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%8A%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[给自己的博客加上图片 前言写博客的时候，有时候图片比文字更有说服力，比如：代码运行结果，本来一张图片解决的事情，不用图片的话，就得自己敲结果，然而别人不一定能看懂，这就非常尴尬了，所以说，在某些时候图片的说服力还是很强大的，比如下面这张表达的意思。 ​ 言归正传，我下面介绍一下我比较相中的办法，因为不用借助七牛等等，当然相比较而言的优缺点就忽略吧。 解决办法1.首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 2.在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 3.在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹。 4.将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片： 1![你想要输入的替代文字](xxxx/图片名.jpg) ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 5.然后，使用hexo g部署的时候，进入public\2018\04\19\index.html文件中查看相关字段，可以发现html标签内的语句是img src = “2018/04/19/xxxx/图片名.jpg”而不是img src=”xxxx.图片名.jpg”，这就成功了，当然前面步骤操作正确的话，这一步也不用检查。 ​ 最后放一张帅照，并感谢Nubb，为你引流233333。]]></content>
      <categories>
        <category>博客杂谈</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断回文串时忽略既非字母又非数字的字符]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2%E6%97%B6%E5%BF%BD%E7%95%A5%E6%97%A2%E9%9D%9E%E5%AD%97%E6%AF%8D%E5%8F%88%E9%9D%9E%E6%95%B0%E5%AD%97%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[判断回文串时忽略既非字母又非数字的字符 问题及解决办法​ 1.question：通过删除既非字母有非数字的字符过滤这个字符串。answer：创建一个新的空字符串构建器，将字符串中每一个字母或数字字符添加到字符串构建器中，然后从这个构建器返回所求的字符串。可以使用Character类中的isLetterOrDigit(ch)方法来检测字符ch是否是数字或字母。 ​ 2.question：倒置过滤后的字符串得到一个新字符串。使用equal方法对倒置后的字符串和过滤后的字符串进行比较。 完整程序PalindromeIgnoreNonAlphanumeric.java 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class PalindromeIgnoreNonAlphanumeric &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.println(&quot;Enter a string:&quot;); String s = input.nextLine(); System.out.println(&quot;Ignoring nonalphanumeric characters,\nis &quot;+s+&quot; a palindrome? &quot;+isPalindrome(s)); &#125; public static boolean isPalindrome(String s)&#123; String s1=filter(s); String s2=reverse(s1); return s2.equals(s1); &#125; public static String filter(String s)&#123; StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i&lt;s.length();i++) &#123; if(Character.isLetterOrDigit(s.charAt(i)))&#123; stringBuilder.append(s.charAt(i)); &#125; &#125; return stringBuilder.toString(); &#125; public static String reverse(String s)&#123; StringBuilder stringBuilder=new StringBuilder(s); stringBuilder.reverse(); return stringBuilder.toString(); &#125;&#125; 输出： 12345678910//ex1:Enter a string:ab&lt;c&gt;b?aIgnoring nonalphanumeric haracters,is ab&lt;c&gt;b?a a palindrome? true//ex2:Enter a string:abcc&gt;&lt;?cabIgnoring nonalphanumeric haracters,is abcc&gt;&lt;?cab a palindrome? false ​ filter(String s)方法逐个检查字符串s中的每个字符，如果字符是字母或者数字字符，就将他复制到字符串构建器。filter方法返回构建器中的字符串。reverse(String s)方法创建一个新字符串，这个新串是对给定字符串s的倒置。filter方法和reverse方法都会返回一个新字符串，原始字符串并没有改变。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toString、capacity、length、setlength和charAt方法]]></title>
    <url>%2F2018%2F04%2F18%2FtoString%E3%80%81capacity%E3%80%81length%E3%80%81setlength%E5%92%8CcharAt%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[toString、capacity、length、setlength和charAt方法 ​ StringBuilder类提供了许多其他处理字符串构建器和获取它的属性的办法。 java.lang.StringBuilder 12345678+toString(): String //从字符串构建器返回一个字符串对象+capacity(): int //返回该字符串构建器的容量+charAt(index: int): char //返回指定索引位置的字符+length(): int //返回该构建器中的字符数+setLength(newLength: int): void//设置该构建器的新长度+substring(startIndex: int): String//返回从startIndex开始的字符串+substring(startIndex: int,endIndex: int):String//返回从startIndex开始endIndex结束的子字符串+trimToSize(): void //减少用于字符串构建器的存储大小 ​ capacity()方法返回字符串构建器当前的容量。容量是指在不增加构建器大小的情况下存储的字符数量。 ​ length()方法返回字符串构建器中实际存储的字符数量，setLength(newLength)方法设置字符串构建器的长度。如果参数newLength小于字符串构建器当前的长度，则字符串构建器会被截短到恰好能包含由参数newLength给定的字符个数。如果参数newLength大于或者等于当前长度，则给字符串构建器追加足够多的空字符(‘\u0000’),使其长度length变成新参数newLength。参数newLength必须大于等于0。 ​ charAt(index)方法返回字符串构建器中某个特定下标index的字符。下标是基于0的，字符串构建器中的第一个字符的下标为0，第二个字符下标为1，以此类推。参数index必须大于或等于0，并且小于字符串构建器的长度。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuilder-----修改StringBuilder中的字符串]]></title>
    <url>%2F2018%2F04%2F17%2FStringBuilder-----%E4%BF%AE%E6%94%B9StringBuilder%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[StringBuilder—–修改StringBuilder中的字符串 要点提示：StringBuilder和StringBuffer类似于String类，区别在于String类是不可变的。 ​ 一般只要使用字符的地方都可以使用StringBuilder和StringBuffer类，可以给一个StringBuilder和StringBuffer类中添加、插入或追加新的内容，而String不行。 多任务并发访问，就是用StringBuffer，因为这种情况下需要同步以防止StringBuffer崩溃。 单任务访问，使用StringBuilder更有效果。 java.lang.StringBuilder 123+StringBuilder() //构建一个容量为16的字符串构建器+StringBuilder(capacity: int) //构建一个指定容量的字符串构建器+StringBuilder(s: String) //构建一个指定字符的字符串构建器 123456789101112+append(data: char[]): StringBuilder //追加一个字符数组到字符串构建器+append(data: char[],offset: int,len: int): StringBuilder//追加data中的子数组到字符串构建器+append(v: aPrimitiveType): StringBuilder//将一个基本类型值作为字符串追加到字符串构建器中+append(s: String): StringBuilder//追加一个字符串到字符串构建器+delete(startIndex: int,endIndex: int): StringBuilder//删除从startIndex到endIndex-1的字符+deleteCharAt(indexL int): StringBuilder//删除给定索引位置的字符+insert(index:int,data: char[],offset: int,len:int): StringBuilder//在字符串构建器的给定索引位置插入数组data的子数组+insert(offset: int,data: char[]): StringBuilder//向构建器偏移位置插入数据+insert(offset: int,b:a: PrimitiveType): StringBuilder//向该字符串构建器插入一个转换为字符串的值+replace(startIndex: int,endIndex: int,s: String): StringBuilder//将该构建器从startIndex到endIndex-1的位置的字符替换为给定的字符串+reverse(): StringBuilder//倒置构建器中的字符+setCharAt(index: int,ch: char): StringBuilder//将该构建器的指定索引位置设置为新的字符 ​ StringBuilder类提供了几个重载方法，可以将boolean、char、char数组、double、float、int、long和String类型值追加到字符串构建器。例如下面的代码将字符串和字符追加到stringBuilder，构成新的字符串”Welcome to Java” 123456StringBuilder stringBuilder=new StringBuilder();stringBuilder.append(&quot;Welcome&quot;);stringBuilder.append(&quot; &quot;);stringBuilder.append(&quot;to&quot;);stringBuilder.append(&quot; &quot;);stringBuilder.append(&quot;Java&quot;); ​ StringBuilderl类也包括几个重载的方法，可以可以将boolean、char、char数组、double、float、int、long和String类型值追加到字符串构建器。 1stringBuilder.insert(11,&quot;HTML and&quot;); 接上条代码，新的stringBuilder就变成了”Welcome to HTML and Java”。 ​ 也可以使用两个delete方法将字符从构建器中的字符串中删除，使用reverse方法导致字符串，使用replace方法替换字符串中的字符，或者使用setCharAt方法在字符串中设置一个新字符。 假设应用下面方法前stringBuilder包含的是”Welcome to Java”。 12345stringBuilder.delete(8,11);//将构建器变为Welcome JavastringBuilder.deleteCharAt(8);//将构建器变为Welcome o JavastringBuilder.reverse();//将构建器变为avaJ ot emocleWstringBuilder.replace(11,15,&quot;HTML&quot;);//将构建器变为Welcome to HTMLstringBuilder.setCharAt(0,&apos;w&apos;);将构建器变为welcome to Java 未完待续…………]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决安卓项目在Android Studio无法打开]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E5%9C%A8Android%20Studio%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%2F</url>
    <content type="text"><![CDATA[如何解决安卓项目在Android Studio无法打开 ​ 在github上下载一些安卓源码项目后，导入到Android Studio的时候无法导入，于是开始网上搜索大佬们的经验，为了避免忘记，还会自己写一篇博客吧，方便自己以后导入项目。 修改三处即可： ①build.gradle文件（在根目录下） 123456dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.3&apos;//将此处版本号改为自己AS的版本 // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125; ​ 如果不知道自己Android Studio的版本的话，新建一个项目，打开同样的文件查看。 ②app文件夹中的build.gradle 1234567891011android &#123; compileSdkVersion 26// buildToolsVersion &quot;26.0.1&quot;// defaultConfig &#123; applicationId &quot;com.example.zhaoxudong.calculatorapp&quot; minSdkVersion 14// targetSdkVersion 26// versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; ​ 用//标注的地方，修改成跟自己Android Studio一样的。 ③gradle/wrapper/gradle-wrapper.properties文件 123456#Mon Dec 28 10:00:20 PST 2015distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip// ​ 将//前面的/gadle-3.3-all.zip里面的数字改为与自己Android Studio一样的。 此时再从Android Studio中导入该项目就可以了。]]></content>
      <categories>
        <category>Android编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BigInteger和BigDecimal类]]></title>
    <url>%2F2018%2F04%2F16%2FBigInteger%E5%92%8CBigDecimal%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[BigInteger和BigDecimal类 要点提示：BigInteger和BigDecimal类可以用于表示任意大小和精度的整数或者十进制数。 ​ 如果要进行非常大的数的计算或者高精度浮点值的计算，可以使用java.math包中的BigInteger和BigDecimal类。他们都是不可变的。long类型的最大整数值为 long.MAX_VALUE（即9223372036854775807）。BigInteger的实例可以表示任意大小的整数。可以使用new BigInteger(String)和new BigDecimal(String)来创建BigInteger和BigDecimal的实例，使用add、subtract、multiple、divide和remainder方法完成算数运算，使用compareTo方法比较两个大数字。例如下面代码创建两个BigInteger对象并且将它们进行相乘： 1234BigInteger a = new BigInteger(&quot;9223372036854775807&quot;);BigInteger b = new BigInteger(&quot;2&quot;);BigInteger c = a.multiply(b);//9223372036854775807*2System.out.println(c); 它的输出为18446744073709551614。 对BigDecimal对象的精度没有限制。如果结果不能终止，那么divide方法会抛出ArithmeticException异常。但是可以使用重载divide(BigDecimal d,int scale,int roundingMode)方法来指定制度和摄入方式来避免这个异常，这里的scale是指小数点后最小的整数位数。例如下面的代码创建两个尺度为20、摄入方式为BigDecimal.ROUND_UP的BigDecimal对象。 1234BigDecimal a = new BigDecimal(1.0);BigDecimal b = new BigDecimal(3);BigDecimal c= a.divide(b,20,BigDecimal.ROUND_UP)；Sysyem.out.println(c); 输出为0.33333333333333333334。 注意，一个整数的阶乘可能会很大，下面的程序给出可以返回任意整数阶乘的方法。 LargeFactorial.java 1234567891011121314package ohhh;import java.math.*;public class LargeFactorial &#123;public static void main(String[] args)&#123; System.out.println(&quot;50! is\n&quot;+factorial(50));&#125; public static BigInteger factorial(long n)&#123; BigInteger result=BigInteger.ONE;//等价于=new BigInteger(&quot;1&quot;) for(int i=1;i&lt;=n;i++) result=result.multiply(new BigInteger(i+&quot;&quot;));//BigInteger(String) return result; &#125;&#125; 输出结果是： 50! is30414093201713378043612608166064768844377641568960512000000000000]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字this引用]]></title>
    <url>%2F2018%2F04%2F16%2Fthis%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关键字this引用 要点提示：关键字this引用独享自身。他也可以在构造方法内部调用另一个类的其他构造方法。 ​ 关键字this是指向调用对象本身的引用名。可以用this关键字引用对象的实例成员。 例如：下面a的代码使用this来显示地引用独享的radius以及调用他的getArea()方法。this引用通常可以省略掉的，如b所示。然而，在引用隐藏数据域的以及调用一个重载的构造方法的时候，this引用是必须的。 12345678910111213141516171819202122//a:public class Circle&#123; private double radius; ..... public double getArea() &#123; return this.radius*this.radius*Math.PI; &#125; public String toString() &#123; return &quot;radius&quot;+this.radius+&quot;area&quot;+this.getArea(); &#125;&#125;//b:public class Circle&#123; private double radius; ..... public double getArea() &#123; return radius*radius*Math.PI; &#125; public String toString() &#123; return &quot;radius&quot;+radius+&quot;area&quot;+getArea(); &#125;&#125; 使用this引用隐藏数据域​ this关键字可以用于引用类的隐藏数据域。例如在数据域set方法中，经常将数据域名用作参数名。在这种情况下，这个数据域在set方法中被隐藏。为了给他设置新值，需要在方法中引用隐藏的数据域名。隐藏的静态变量可以简单的通过“类名.静态变量”的方式引用。隐藏的实例变量就需要使用关键字this来引用了。 1234567891011public class F &#123; private int i = 5; private static double k = 0; public void setI(int i)&#123; this.i = i; &#125; public static void setK(double k) &#123; F.k = k; &#125; //other menthods omitted&#125; 使用this调用构造方法​ 关键字this可以用于调用同一个类的另一个构造方法。例如，可以如下改写Circle类： 123456789public class Circle &#123; private double radius; public Circle(double radius) &#123; tihs.radius = radius; //this关键字用于引用所构建的对象的隐藏数据radius &#125; public Circle() &#123; tihs(1.0); //this关键字用来调用另一个构造方法 &#125;&#125; ​ 在第二个构造方法中，this(1.0)这一行调用带double值参数的第一个构造方法。 注意：Java要求在构造方法中，语句this(参数列表)应在任何其他可执行语句之前出现。 提示：如果一个类有多个构造方法，最好尽可能的使this(参数列表)实现它们。通常，无参数或参数少的构造方法可以用this(参数列表)调用参数多德构造方法。这样做通常可以简化代码，使类便于阅读和维护。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java库中的Point2D类]]></title>
    <url>%2F2018%2F04%2F15%2FJava%E5%BA%93%E4%B8%AD%E7%9A%84Point2D%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java库中的Point2D类 javafx.geometry.Point2D +Point2D(x: double,y: double) //用给定的x和y坐标来创建一个Point2D对象 +distance(x: double,y: double): double //返回该点到定点（x,y）的距离 +distance(p: Point2D): double //返回该点到p点的距离 +getX(): double //返回该点的x的坐标 +getY(): double //返回该点的y的坐标 +toString(): String //返回该点的字符串表示 12345678910111213141516171819import java.util.Scanner;import javafx.geometry.Point2D;public class TestPoint2D &#123;public static void main(String[] args)&#123; Scanner input= new Scanner(System.in); System.out.println(&quot;Enter point1&apos;s x-,y-coordinates:&quot;); double x1=input.nextDouble(); double y1=input.nextDouble(); System.out.println(&quot;Enter point2&apos;s x-,y-coordinates:&quot;); double x2=input.nextDouble(); double y2=input.nextDouble(); Point2D p1 =new Point2D(x1,y1); Point2D p2 =new Point2D(x2,y2); System.out.println(&quot;p1 is&quot;+p1.toString()); System.out.println(&quot;p2 is&quot;+p2.toString()); System.out.println(&quot;distance is&quot;+p1.distance(p2)); &#125; &#125; 为什么会把这个类单拿出来呢，因为在eclipse运行的时候，你会发现会报错，难道是书写错了？不不不，下面是答案： 这是因为这个类是Eclipse的JRE带的，但并不属于JAVA的公开API。解决方法：右击项目-&gt;属性-&gt;Java Compiler-&gt;Errors/Warnings-&gt;Deprecated and restricted API-&gt;Forbidden reference -&gt; Ignore 运行结果 1234567Enter point1&apos;s x-,y-coordinates:1 2Enter point2&apos;s x-,y-coordinates:3 4p1 isPoint2D [x = 1.0, y = 2.0]p2 isPoint2D [x = 3.0, y = 4.0]distance is2.8284271247461903]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Java库中的类]]></title>
    <url>%2F2018%2F04%2F15%2F%E4%BD%BF%E7%94%A8Java%E5%BA%93%E4%B8%AD%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[使用Java库中的类 Date类java.util.Date +Date() //为当前时间创建一个Date对象 +Date(elapseTime: long)//为一个从格林威治时间1970年1月1日至今流逝的以毫秒为单位计算的给定时间创建的Date对象 +toString(): String //返回一个代表日期和时间的字符串表示 +getTime(): long //返回从格林威治时间1970年1月1日至今流逝的毫秒数 +setTime(elapseTime: long): void //在对象中设置一个新的流逝时间 123456java.util.Date date = new java.util.Date();System.out.println(&quot;The elapsed time since Jan 1,1970 is&quot;+date.getTime()+&quot;milliseconds&quot;);System.out.println(date.toString());//输出：The elapsed time since Jan 1,1970 is1523760077427millisecondsSun Apr 15 10:41:17 CST 2018 Random类java.util.Random +Random() //以当前时间创建一个Random对象 +Random(seed: long) //以一个特定的值作为种子创建一个Random对象 +nextInt(): int //返回一个随机的int值 +nextInt(n: int): int //返回一个0到n之间的随机int类型的数 +nextLong(): long //返回一个0到n之间的随机long值 +nextDouble(): double //返回一个0.0到1.0（不包含1.0）之间的随机double类型的值 +nextFloat(): float //返回一个0.0F到1.0F（不包含1.0F）之间的随机float类型的值 123456789101112131415161718192021java.util.Random random1 = new java.util.Random(3);System.out.println(&quot;From random1:&quot;);for(int i=0;i&lt;10;i++) System.out.print(random1.nextInt(1000)+&quot; &quot;); java.util.Random random2 = new java.util.Random(3);System.out.println(&quot;\nFrom random2:&quot;);for(int i=0;i&lt;10;i++) System.out.print(random2.nextInt(1000)+&quot; &quot;); java.util.Random random3 = new java.util.Random();System.out.println(&quot;\nFrom random3:&quot;);for(int i=0;i&lt;10;i++) System.out.print(random3.nextInt(1000)+&quot; &quot;);//输出：From random1:734 660 210 581 128 202 549 564 459 961 From random2:734 660 210 581 128 202 549 564 459 961 From random3:384 412 586 796 729 521 52 718 586 355 还有一个类，我们在下一篇文章介绍，有一点特殊。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类多文件运行]]></title>
    <url>%2F2018%2F04%2F14%2FJava%E7%B1%BB%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Java类多文件运行 TV类对电视机的建模：​ channel: int //这个TV的当前频道（从1到120） ​ volumeLevel: int //这个TV的当前音量（从1到7） ​ on: boolean //表明这个TV是开的还是关的 ​ +TV() //构造一个默认的TV对象 ​ +turnOn(): void //打开这个TV ​ +turnOff(): void //关闭这个TV ​ +setChannel(newChannel: int): void //为这个TV设置一个新频道 ​ +setVolume(newVolumeLevel: int): void //为这个TV设置一个新音量 ​ +channelUp(): void //给频道数+1 ​ +channelDown(): void //给频道数-1 ​ +volumeUp(): void //给音量+1 ​ +volumeDown:void //给音量-1 TV.java文件TV类中的构造方法定义为公共的，因此可以从其他类中访问。 123456789101112131415161718192021222324252627282930313233343536public class TV &#123; int channel = 1; int volumeLevel = 1; boolean on = false; public void turnOn()&#123;//开 on = true; &#125; public void turnOff()&#123;//关 on = false; &#125; public void setChannel(int newChannel)&#123; if(on &amp;&amp; newChannel &gt;= 1&amp;&amp; newChannel &lt;= 120) volumeLevel = newChannel; &#125; public void setVolume(int newVolumeLevel)&#123; if(on &amp;&amp; newVolumeLevel &gt;=1 &amp;&amp; newVolumeLevel &lt;=7) volumeLevel = newVolumeLevel; &#125; public void channelUp()&#123; if(on &amp;&amp; channel &lt; 120) channel++; &#125; public void channelDown()&#123; if (on &amp;&amp; channel &gt; 1) channel--; &#125; public void volumeUp()&#123; if(on &amp;&amp; volumeLevel &lt; 7) volumeLevel++; &#125; public void volumeDown()&#123; if(on &amp;&amp; volumeLevel &gt; 1) volumeLevel--; &#125;&#125; TestTV.java文件第3行和第8行创建了两个对象，然后调用对象中的方法来完成设置频道和音量的动作。 12345678910111213141516public class TestTV &#123; public static void main(String[] args)&#123; TV tv1 = new TV(); tv1.turnOn();//tv1 开 tv1.setChannel(30);//频道 30 tv1.setVolume(3);// 音量 3 TV tv2 = new TV(); tv2.turnOn();// tv2 开 tv2.channelUp();// tv2 频道+1 tv2.volumeUp();//tv2 音量+1 System.out.println(&quot;tv1的频道是&quot;+tv1.channel+&quot;声音是&quot;+tv1.volumeLevel); System.out.println(&quot;tv2的频道是&quot;+tv2.channel+&quot;声音是&quot;+tv2.volumeLevel); &#125;&#125; 运行结果12tv1的频道是1声音是3tv2的频道是2声音是2]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客添加搜索功能]]></title>
    <url>%2F2018%2F04%2F13%2Fhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[hexo博客添加搜索功能 前言 当博文慢慢变多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博客上去，所以添加一个本站内搜索功能是很有必要的。 安装插件直接在自己的博客文件夹下（我的是blog）点击鼠标右键选择Git Bash Here 1npm install hexo-generator-searchdb --save 修改站点配置文件我的路径是：blog下的_config.yml文件，进行编辑。 12345search： path: search.xml field: post format: html limit: 10000 PS:每个冒号后面都有空格。 修改主题配置文件我的路径：/blog/themes/next下的_config.yml文件，进行编辑。 12local_search: enable: true PS:冒号后面都有空格。 此时，部署到github，打开网页就可以看到搜索功能了，容易添加，使用起来很方便，推荐添加，增加网站友好度。]]></content>
      <categories>
        <category>博客杂谈</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客添加评论神器---valine]]></title>
    <url>%2F2018%2F04%2F12%2Fhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%A5%9E%E5%99%A8---valine%2F</url>
    <content type="text"><![CDATA[hexo博客添加评论神器—valine 我们评论系统是放在LeanCloud上的，因此需要先去注册一个账号。 LeanCloud官网，点击注册 注册完成后需要创建一个应用，创建成功以后，进入应用→设置→应用key 获取到了你的appid和appkey 1234567App IDXXXXXXXXXXXXXXXXXXXXXXXXXX每个app有一个唯一的ID，不可变更App KeyXXXXXXXXXXXXXXXXXXXXXXXXXX适用于所有平台 拥有了你的appid和appkey后，打开主题配置文件（blog/themes/next/_config.yml）填写appid和appkey 123456789valine： enable: true appid: your app id //你获取的appid appkey your app key //你获取的app key notifiy: false # mail notifier,https://github.com/xCss/Valine/wiki //是否开启邮箱提醒 verfify: false # Verifaication code //开启验证码 planceholde: 评论内容。 //你要发表的评论内容 guest_info: nick,mail,link pageSize: 10 PS：配置的时候自行删除”//“开始以后的注释内容，同时如果开启邮箱提醒的话，会默认开启验证码模式。 完成这些以后还需要在LeanCloud中，进入应用→设置→安全中心在Web 安全域名中填写自己的博客首页，然后保存。 最后部署到github，打开自己的博客就可以看到评论功能，有没有点小激动，快去邀请小伙伴发表评论吧。]]></content>
      <categories>
        <category>博客杂谈</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器的设计与实现]]></title>
    <url>%2F2018%2F04%2F11%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[词法分析器的设计与实现 词法分析器介绍 词法分析是从左到右扫描每行源程序的符号，拼成单词，换成统一的机内表示形式——TOKEN字，送给语法分析程序。 TOKEN字是一个二元式：（单词种别码，自身值）。单词自身值按如下规则给出： ​ 1.标识符的自身值是他在符号表的入口位置。 ​ 2.常数的自身值是常数本身（或者其他二进制数值）。 ​ 3.关键字和界限符的自身值为本身。 词法分析器功能1.输入：字符串（带进行词法分析的源程序），可从键盘直接输入或从文件读入。 输出：由（种别码，自身值）所组成的二元组序列。 单词的种别码是语法分析需要的信息，可用整数编码表示，例如：标识符的种别码为1，常数为2，保留字为3，运算符为4，界符为5。 单词的自身值是编译其他阶段需要的信息，标识符的自身是标识符在符号表入口，其他类型单词的自身值是其本身。 例如：输入：if i &gt;= 15 then x := y ; ​ 输出： ​ （3，if） ​ （1，0）//i符号的入口为0 ​ （4，&gt;=） ​ （2，15） ​ （3，then） ​ （1，1）//x符号的入口为1 ​ （4，：=） ​ （1，2）//y符号的入口为2 ​ （5，；） 2.功能： a.滤过空格。 b.识别保留字：if then else while do 等。 c.识别标识符：&lt;字母&gt;(&lt;字母&gt;|&lt;数字&gt;)。 d.识别整数：0|(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)。 e.识别典型的运算符和分隔符，例如：+ - * / &gt; &gt;= &lt;= ( ) ; 3.具有一定的错误处理功能，例如：能检查出程序语言的字符集以外的非法字符。 源码附带注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;string&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;bool isLetter(char ch)&#123;//isLetter 标识符 if ((ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) || (ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;)) return true; else return false;&#125;bool isDigit(char ch)&#123;//isDigit 常数 if (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) return true; else return false;&#125;bool isOperators(char ch)&#123;// isOperators 运算符 if (ch == &apos;+&apos; || ch == &apos;*&apos; || ch == &apos;-&apos; || ch == &apos;/&apos; || ch == &apos;=&apos; || ch == &apos;:&apos; || ch == &apos;&lt;&apos; || ch == &apos;&gt;&apos;) return true; else return false;&#125;bool isDelimiter(char ch)&#123;// isDelimiter 界符 if (ch == &apos;,&apos; || ch == &apos;;&apos; || ch == &apos;.&apos; || ch == &apos;(&apos; || ch == &apos;)&apos; || ch == &apos;[&apos; || ch == &apos;]&apos; || ch == &apos;&#123;&apos; || ch == &apos;&#125;&apos; || ch == &apos;#&apos;) return true; else return false;&#125;bool isBlank(char ch)&#123; if (ch == &apos; &apos; || ch == &apos;\t&apos;) return true; else return false;&#125;char key[34][10] = &#123; &quot;main&quot;,&quot;auto&quot;, &quot;short&quot;, &quot;int&quot;, &quot;long&quot;, &quot;float&quot;, &quot;double&quot;, &quot;char&quot;, &quot;struct&quot;, &quot;union&quot;, &quot;enum&quot;, &quot;typedef&quot;, &quot;const&quot;, &quot;unsigned&quot;, &quot;signed&quot;, &quot;extern&quot;, &quot;register&quot;, &quot;static&quot;, &quot;volatile&quot;, &quot;void&quot;, &quot;if&quot;, &quot;else&quot;, &quot;switch&quot;, &quot;case&quot;, &quot;for&quot;, &quot;do&quot;, &quot;while&quot;, &quot;goto&quot;, &quot;continue&quot;, &quot;break&quot;, &quot;default&quot;, &quot;sizeof&quot;, &quot;return&quot;,&quot;then&quot;&#125;;void main()&#123;back: char Sourcecode[100] = &quot;&quot;; int number=0; int h=0; char hh[100][10]=&#123;&apos;\0&apos;&#125;; //声明变量 printf(&quot;请输入程序段，标识符为1，常数为2，关键字为3，运算符4，界符5\n&quot;); gets(Sourcecode); //读入程序段放入firstcode for (int i = 0; i &lt; 100; i)&#123; //char delimiter[2] = &quot;&quot;; int j = 0; //letter 标识符 int l = 0; //digit 常数 int k = 0; //operators 运算符 int b = 0; //类型编号 char num[10] = &quot;&quot;; char word[10] = &quot;&quot;; if (isBlank(Sourcecode[i]) == 1)&#123; i += 1; &#125;//去空格 else&#123; if (isLetter(Sourcecode[i]) == 1) //是否为字母 &#123; //是 do &#123; if (j &lt; 10)&#123; word[j] = Sourcecode[i]; j++; &#125; &#125; while (isDigit(Sourcecode[++i]) == 1|| isLetter(Sourcecode[i]) == 1);//常数||标识符 //*~~~* int a = 0; while (a &lt; 34)&#123; if (strcmp(key[a], word) == 0)&#123; b = 3; a++; break; &#125; else &#123; b = 1; a++; //否 &#125; &#125; if (b == 3)&#123; printf(&quot;(3,%s)\n&quot;, word); &#125;//~~~~~~~~~~~~~~~~~~~~~~~~ if (b == 1){ int q=0; for(int qq=0;strcmp(hh[qq],&quot;&quot;)!=0;qq++){ if(strcmp(word,hh[qq])==0){ q=1;break; } } if(q==1){ printf(&quot;(1,%d)\n&quot;,qq); q=0; }else{ for(qq=0;qq&lt;j;qq++){ hh[h][qq]=word[qq]; } printf(&quot;(1,%d)\n&quot;,h); h++; } /* int qq,yy=0; if(h==0){ for(qq=0;qq&lt;j;qq++){ hh[0][qq]=word[qq]; } printf(&quot;(1,%d)\n&quot;,h); h++; }else{ for(qq=0;qq&lt;h;qq++){ if(strcmp(hh[qq], word)==0){ yy=1; break; } } if(yy==0){ for(qq=0;qq&lt;j;qq++){ hh[h][qq]=word[qq]; } printf(&quot;(1,%d)\n&quot;,h); h++; yy=0; } else{ for(qq=0;qq&lt;h;qq++){ if(strcmp(hh[qq], word)==0) printf(&quot;(1,%d)\n&quot;,qq); yy=0; } } }*/ // } //1234567891011121314151617181920212223242526272829303132333435363738394041424344 &#125; else if (isDigit(Sourcecode[i]) == 1)//常数 &#123;int c = 0; while (isDigit(Sourcecode[i]))&#123; num[c] = Sourcecode[i]; i += 1; c++; &#125; printf(&quot;(2,%s)\n&quot;, num); &#125; else if (isDelimiter(Sourcecode[i]) == 1)&#123;//界符 printf(&quot;(5,%c)\n&quot;, Sourcecode[i]); i++; &#125; else if (isOperators(Sourcecode[i]) == 1)&#123;//运算符 if (Sourcecode[i] == &apos;:&apos; || Sourcecode[i] == &apos;&gt;&apos; || Sourcecode[i] == &apos;&lt;&apos;&amp;&amp;Sourcecode[i + 1] == &apos;=&apos;)&#123; printf(&quot;(4,%c%c)\n&quot;, Sourcecode[i], Sourcecode[i + 1]); i += 2; &#125; else&#123; printf(&quot;(4,%c)\n&quot;, Sourcecode[i]); i+= 1; &#125; &#125; else&#123; if(Sourcecode[i]!=&apos;\0&apos;) printf(&quot;(error,%c)\n&quot;,Sourcecode[i]); if(Sourcecode[i+1]!=&apos;\0&apos;)&#123; i+=1;&#125; else i=100; &#125; &#125; &#125; goto back;&#125; 编程感悟1.需要对是否为标识符、常数、保留字、运算符、界符进行判断，应用布尔类型完美的解决这个问题。 2.++i与i++都是i=i+1的含义，但是++i表示执行前i=i+1，而i++表示执行后i=i+1。 3.用一维数组来表示字符串，二维数组用来表示字符串的集合，并且用strcmp(string_1,string_2)来进行字符串内容的比较，相同返回0。 4.对于相同的标识符来说，入口应该相同，所以在对这里进行处理的时候，声明一个二维数组用来存放各个标识符（字符或者字符串），根据二维数组中的行下标进行入口标记。 5.好好学习一维数组、二维数组的应用场景以及应用原理。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行计算π值]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[并行计算π值 并行计算定义 并行计算或称平计算是相对于串行计算来说的。它是一种一次可执行多个指令的算法，目的是提高计算速度，及通过扩大问题求解规模，解决大型而复杂的计算问题。所谓并行计算可分为时间上的并行和空间上的并行。时间上的并行就是指流水线技术，而空间上的并行则是指用多个处理器并发的执行计算。 并行计算特征1、将工作分离成离散部分，有助于同时解决； 2、随时并及时地执行多个程序指令； 3、多计算资源下的解决问题的耗时要少于单个计算资源下的耗时。 网络设置并行计算机是靠网络将各个处理机或者处理器连接起来的，一般有以下几种方式，处理单元间有着固定连接的一类网络，在程序执行期间，这种点到点的链接保持不变。 命令配置IP地址1.点击菜单栏右侧的wifi图标，选择Edit Connections按钮。 2.点击Edit按钮编辑现有的有线连接。切换到IPV4 Settings选项卡，Method选择手动设置IP模式（Manual），点击add按钮添加IP。IP地址自行设定（如：192.168.0.1）保证4个节点在同一网段（网关相同）。子掩码255.255.255.0，网关根据IP设置（如：192.168.0.1），保存即设定成功。（可能需要手动点击wifi选择Ethernet Connection1） 安装ssh服务1234sudo dpkg -i libck*sudo dpkg -i openssh-client*sudo dpkg -i openssh-sftp*sudo dpkg -i openssh-server* 启动ssh服务1sudo service ssh start 安装MPICH2123456789cd//切换到家目录cp softWare/mpich2-1.0.6.tar.gz ./ //回车复制软件包到家目录tar zxf mpich2-1.0.6.tar.gz //回车解压目录mv mpich2-1.0.6 mpich2 //回车对文件夹进行重命名cd mpich2 //回车切换到软件根目录./configure //运行配置文件，运行后会输出很多的信息，请注意过程中是否有Error信息make //编译软件，运行后会输出很多的信息，请注意过程中是否有Error信息sudo make install //运行后会输出很多信息，请注意过程中是否有Error信息//到此MPICH2 安装完成 检测MPICH2是否安装成功123456which mpd//输出：/usr/local/bin/mpdwhich mpiexec//输出：/usr/local/bin/mpiexecwhich mpdboot//输出：/usr/local/bin/mpdboot 配置系统文件1.切换到集群机的第一个节点，打开终端。输入命令cd回车切换到家目录。 2.输入nano .mpd.conf//建立MPICH2的配置文件。并在窗口中输入MPD_SECRETWORD=123456,然后 ctrl+shift+o保存更改，回车，最后ctrl+x退出nano编辑器（注意.mpd.conf是隐藏文件，需要ls -al才能看 见，文件结尾不要换行） 3.输入chmod 600 .mpd.conf//修改文件权限 4.nano mpd.hosts//建立集群节点的列表文件，并在窗中输入参与节点的主机名，文件结尾不要换行。然 后保存关闭窗口。 5.输入命令 sudonano /etc/hosts 修改系统host文件 。将第二行的127.0.0.1修改为本机的IP地址。忘记IP 地址可以使用 ifconfig 命令查看。最后再把其他运算节点的IP 和 主机名加入到host 文件中。保存并退出 nano 编辑器。 6.输入命令 ping 主机名 检查是否能够与其他主机联通，如果不能联通 使用 ping IP地址 的方式检查。如果 不能ping 通主机名，检查是否正确修改 /etc/hosts 文件 ，如果不能ping 通 IP 检查节点是否正确连接有线网 络，或者IP地址是否正确。 7.输入命令 ssh-keygen 生成SSH密钥，过程中一路回车，不需要进行输入操作。 8.输入命令 cd .ssh 切换到ssh目录。通过ls 命令查看目录下面的文件，再输入命令 cp id_rsa.pub authorized_keys 复制公钥为认证密钥 ，通过 ls 命令显示目录下的文件。 9.输入命令 cd切换到家目录。 再输入命令 scp -r .sshgjy@011225-2:~/ 将ssh目录复制到其他节点。 （scp 为远程复制命令，该命令需要执行多次将ssh目录复制到每一个节点 用户名@**主机名），第一次复 制需要输入yes，然后输入密码。 10.输入命令 scp /etc/hosts .mpd.conf mpd.hosts gjy@011225-2:~/ 将3个文件复制到其他节点。（该 命令需要执行多次，此时已经不需要输入密码，如果还需要密码，则ssh免密码登陆没有生效，请检查步骤 6、7、8操作是否正确）。 11.输入命令 ssh 用户名@主机名（如 ssh gjy@011225-2） 登陆到其他节点。 12.输入命令 sudomv hosts /etc/替换本机etc目录下的hosts 文件。 13.输入命令 exit 退出远程登陆。重复 9 ~ 12 步，直到每个节点都有这3个文件。 做π的并行计算123mpdboot -n 4 -f mpd.hosts //启动并行运算节点。（4为所有运算节点数 ，不能超过mpd.host文件中定义的主机数）mpdtrace -l //查看所有启动的节点mpiexec -n 4 ./mpich2/examples/cpi //并行计算PI值（4为运算的进程数，可以任意定义） 运行其他程序1.编译文件 queen.c 1mpicc -o queen queen.c//编译完成将生成一个叫.queen的文件 2.拷贝可执行文件到其他节点 12scp queen gjy@011224-2:~/scp queen gjy@011224-2:~/ 3.并行计算 1mpiexec -n 4 ./queen]]></content>
      <categories>
        <category>并行计算</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>并行计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String类型的骚操作（2）]]></title>
    <url>%2F2018%2F03%2F19%2FJava%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java中String类型的骚操作（2） String类包含的获取子串的方法 方法 描述 substring(beginIndex) 返回该字符串的子串，从特定位置beginIndex的字符开始到字符串的结尾 substring(beginIndex,endIndex) 返回该字符串的子串，从特定位置beginIndex的字符开始到下标为endIndex-1的字符 1）使用substring(beginIndex)方法： 123String message = &quot;Welcome to Java&quot;;Strnig s1 = message.substring(11);System.out.println(s1);//返回Java 这里需要注意的是“W”其实是第0个字符，所以“J”是第11个字符。 2）使用substring(beginIndex,endIndex)方法： 123String message = &quot;Welcome to Java&quot;;String s1 = message.substring(0,10);System.out.println(s1);//返回Welcome to 获取字符串中的字符或者子串 方法 描述 indexOf(ch) 返回字符串中出现的第一个ch的下标，如果没有匹配的，返回-1 indexOf(ch,fromIndex) 返回字符串中的fromIndex之后出现的第一个ch的下标，如果没有匹配的，返回-1 indexOf(s) 返回字符串中出现的第一个字符串s的下标，如果没有匹配，返回-1 indexOf(s,fromIndex) 返回字符串中fromIndex后出现的第一个字符串s的下标，如果没有匹配的，返回-1 lastIndexOf(ch) 返回字符串中出现的最后一个ch的下标，如果没有匹配，返回-1 lastIndexOf(ch,fromIndex) 返回字符串中fromIndex之前出现的最后一个ch的下标，如果没有匹配的，返回-1 lastIndexOf(s) 返回字符串中出现的最后一个字符串s的下标，如果没有匹配的，返回-1 lasIndexOf(s,fromIndex) 返回字符串忠fromIndex之前出现的最后一个ch的下标，如果没有匹配的，返回-1 1）使用indexOf(ch)方法和indexOf(ch,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.indexOf(&quot;W&quot;));//返回 0System.out.println(message.indexOf(&quot;0&quot;,5));//返回9 2）使用indexOf(s)方法和indexOf(s,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.indexOf(&quot;come&quot;));//返回3System.out.println(message.indexOf(&quot;Java&quot;,5));//返回11 3）使用lastIndexOf(ch)方法和lastIndexOf(ch,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.lastIndexOf(&quot;W&quot;));//返回0System.out.println(message.lastIndexOf(&quot;o&quot;,5));//返回4 4）使用lastIndexOf(s)方法和lastIndexOf(s,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.lastIndexOf(&quot;come&quot;));//返回3System.out.println(message.lastIndexOf(&quot;Java&quot;,5));//返回-1 PS:写的时候indexOf(“w”)和indexOf(‘w’)是一样的，用””和’’都行。 ​ 字符串的骚操作就告一段落了。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String类型的骚操作（1）]]></title>
    <url>%2F2018%2F03%2F18%2FJava%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Java中String类型的骚操作 String对象的简单实用方法 方法 描述 length() 返回字符串中的字符数 charAt(index) 返回字符串中指定位置的字符 concat（s1） 将本字符串和字符串s1相连，返回一个新的字符串 toUpperCase() 返回一个新的字符串，只有大写字母 toLowerCase() 返回一个新的字符串，只有小写字母 trim() 返回一个新的字符串，去掉了两边的空白字符 1)使用length()方法获取长度： 12String message = &quot;Welcome to Java&quot;；System.out.println(&quot;The length of &quot;+message+&quot;is&quot;+message.length()); 显示： 1The length of Welcome to Java is 15 2)使用charAt(index)方法获取字符： 12String message = &quot;Welcome to Java&quot;；System.out.println(message.charAt(0)); 显示： 1W 3）使用concat(s2)连接字符串： 1234String s1 = &quot;Welcome to&quot;;String s2 = &quot;Java&quot;;Strnig s3=s1.concat(s2);System.out.println(s3); 显示： 1Welcome to Java 4)使用toUpperCase()、toLowerCase()实现字符串的转换： 12345String message = &quot;Welcome to Java&quot;;String s2 = message.toUpperCase(message);String s3 = message.toLowerCase(message);System.out.println(s2);System.out.println(s3); 显示： 12WELCOME TO JAVAwelcome to java String 对象的比较方法 方法 描述 equals(s1) 如果该字符串等于字符串s1，返回true equalsIgnoreCase(s1) 如果该字符串等于字符串s1，返回true，不区分大小写 compareTo(s1) 返回一个大于0、等于0、小于0的整数，表明字符串是否大于、等于、小于s1 compareToIgnoreCase(s1) 和compareTo(s1)一样，除了不区分大小写之外 startsWith(prefix) 如果字符串以特定的前缀开始，返回true endsWith(suffix) 如果字符串以特定的后缀结束，返回true contains(s1) 如果s1是该字符串的子字符串，返回true 1）使用“==”只能检测字符串是否指向同一个对象，而equals方法可以判断两个字符串内容是否相同。 12345String s1 = &quot;Welcome to Java&quot;;String s2 = &quot;Welcome to java&quot;;String s3 = &quot;Welcome to maliao&quot;;System.out.println(s1.equals(s2));//return trueSystem.out.println(s1.equals(s3));//return false 2）compareTo方法也可以比较字符串，按照字典顺序（Unicode码的顺序）进行比较。 123String s1 = &quot;abc&quot;;String s2 = &quot;abg&quot;;System.out.println(s1.compareTo(s2));//返回-4 3）startsWith(prefix)、endsWith(suffix)的使用方法： 12345String s1 = &quot;Welcome to Java&quot;;System.out.printn(s1.startsWith(&quot;We&quot;));//return trueSystem.out.println(s1.startsWith(&quot;we&quot;));//return falseSystem.out.println(s1.endsWith(&quot;va&quot;);//retrun trueSystem.out.println(s1.endsWith(&quot;Va&quot;));//return false String的更多骚操作请见下一条博客。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非凡匠心]]></title>
    <url>%2F2018%2F03%2F14%2F%E9%9D%9E%E5%87%A1%E5%8C%A0%E5%BF%83%2F</url>
    <content type="text"><![CDATA[非凡匠心 节目介绍 今天给大家推荐一档节目，名字叫做《非凡匠心》，由张国立带队并且每一期带一个新嘉宾，去寻求国宝级非物质文化遗产代表人，并向他们学习中国传统文化。每一期嘉宾都有他们自己的特点，有的是综艺大咖，有的是歌手、演员等等。当然，每期张国立老师必在（第二季第二期不在，原因自寻），张国立老师可以说是非常适合这个节目了，当然不是说其他人不合适，而是张国立老师积累了大半辈子演艺经验以及生活经验，不论学习什么，都不会显得束手无策、无从下手。又不论与什么人交流，都游刃有余并且还会一些地方方言，能够迅速拉近人与人之间的距离。可以说，节目组选择张国立老师是一个明智的原则。 推荐原因 本人是从第二期开始看的，目前一共播出五期，第一期“张国立携任贤齐勇闯龙泉求宝剑”，第二期“海清独自挑战造纸工艺”，第三期“张国立高晓菲师兄妹直面“窑死窑生””，第四期“张国立杨迪同赴山西求学制药秘诀”，第五期“张国立李玉刚演绎皮影戏版“贵妃醉酒””。而正是因为最近更新的这一期“皮影戏”让我更加有了推荐大家去看的想法（之前看第一期的时候就有推荐）。 第五期中，张国立老师和李玉刚来到了陕西华县高塘镇魏家塬村，这里是五人忙（华县）皮影戏的发源地。首先来到的是魏金全家，并在这里取景落镜。这次的五个人分别是：前声（吕崇德）、签手（魏金全）、上档（刘东耀）、下档（刘华）、后台（魏亚民）。其中最有特点两位便是吕崇德和刘华。吕崇德老师坚守传统，不希望破坏皮影戏特有的”碗碗腔“，不想让皮影戏变得“土不土，洋不洋“。而刘华老师认为不能老停留在这个原汁原味上，应该整个社会与时俱进。弹幕有人说评论说”刘华老师思想前卫“，”吕崇德老师腐朽顽固“。其实，两位老师何尝不想既保持原汁原味又能传承下去，只是时代不一样了，必须要做出这个鱼和熊掌不可兼得的选择。两位老爷子我都很喜欢，可能因为吕崇德老爷子是前声的原因，当他唱出来的时候，每每都感觉震撼心酸。震撼是中华传统文化的博大精深，心酸的是只剩下这么几个老爷子还在坚持着，或许真的像他们自己说的那样：“也就剩十来年了吧”。当李玉刚找到他们并告明来意后，看得出每个人对能够再次登台演出，十分欣喜，甚至迫不及待并且在演出时穿上了最隆重的衣服，或许皮影戏就是他们的全部。在表演准备阶段，每个人都认真地准备着，像整理着装准备奔赴战场的士兵。演出过程中，张国立老师突然忘词，全场一片安静，正在这个时候，吕崇德老师立马接上张国立老师的台词，保证了演出的继续。镜头转向他的时候，吕崇德老师，面无表情，可以看得出内心的平静，这可能就是一种境界吧。也或许是像弹幕抖得机灵一样：“你这样的学生我见得多了”。如果学生真的多，那该多好。与其说他们是华县皮影戏的老戏骨、老艺术家，不如称他们为华县皮影戏的精神，无形无味，却让人望而生畏。 感悟 有些记忆，很轻很轻，像在梦里回到过去。有些牵挂，很重很重，想要离开就是一生的悲欣。对皮影大师而言，光影是多么神秘的游戏。灯光一亮，碗碗腔一起，一夫当关的骁勇酣畅。美景良辰的赏心乐事，都是往昔，散落在时光里的珍宝。更是梦境的永续留存。 希望像华县皮影戏这样的非物质文化遗产能够很好的传承下去，不要在我们这一代丢失。也希望这些老艺术家们能够健健康康、长命百岁。为你们深深的鞠一躬！ 文字非常稚嫩，希望各位观众老爷包容。]]></content>
      <categories>
        <category>生活小调</category>
      </categories>
      <tags>
        <tag>节目推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓简易计算器]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%AE%89%E5%8D%93%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[安卓简易计算器 安卓 Android是由Andy Rubin创立的一个手机操作系统，后来被Google收购。Gooole希望与各方面共同建立一个标准化的、开放式的移动电话软件平台，从而在移动产业形成一个开放式的操作平台。 界面编程 安卓常用的几种布局：线性布局（LineraLayout）、表格布局（Tablelayout）、帧布局（FrameLayout）、相对布局（RelativeLayout）等等。我这里用的是比较简单的“线性布局”。 布局文件（activity_main.xml）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.example.zhaoxudong.calculatorapp.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; tools:layout_editor_absoluteY=&quot;0dp&quot; tools:layout_editor_absoluteX=&quot;0dp&quot;&gt; &lt;EditText android:layout_width=&quot;403dp&quot; android:layout_height=&quot;155dp&quot; android:id=&quot;@+id/result_Text&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;CE&quot; android:id=&quot;@+id/CE&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;DEL&quot; android:id=&quot;@+id/DEL&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;SIN&quot; android:id=&quot;@+id/SIN&quot;/&gt; &lt;Button android:layout_width=&quot;113dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;COS&quot; android:id=&quot;@+id/COS&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;7&quot; android:id=&quot;@+id/number7&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;8&quot; android:id=&quot;@+id/number8&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;9&quot; android:id=&quot;@+id/number9&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;117dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;+&quot; android:id=&quot;@+id/add_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;4&quot; android:id=&quot;@+id/number4&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;5&quot; android:id=&quot;@+id/number5&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;6&quot; android:id=&quot;@+id/number6&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;117dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;-&quot; android:id=&quot;@+id/sub_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;1&quot; android:id=&quot;@+id/number1&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;2&quot; android:id=&quot;@+id/number2&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;3&quot; android:id=&quot;@+id/number3&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;116dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;*&quot; android:id=&quot;@+id/mult_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;=&quot; android:id=&quot;@+id/sign_but&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;0&quot; android:id=&quot;@+id/number0&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;.&quot; android:id=&quot;@+id/spot_but&quot;/&gt; &lt;Button android:layout_width=&quot;114dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;/&quot; android:id=&quot;@+id/div_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 界面效果： 逻辑部分 逻辑部分是由java代码实现，实践证明代码多练还是有好处的。 为了实现按钮的点击事件： 1public class MainActivity extends Activity implements OnClikListener&#123;&#125; 对layout中的按钮进行定义： 1234567891011121314151617181920212223242526272829303132333435private Button number0;private Button number1;private Button number2;private Button number3;private Button number4;private Button number5;private Button number6;private Button number7;private Button number8;private Button number9;/*运算符 */private Button add_but;//加法private Button sub_but;//减法private Button mult_but;//乘法private Button div_but;//除法/*等号小数点归零 */private Button sign_but;//等号private Button spot_but;//小数点private Button CE_but;//归零键private Button DEL;private Button SIN;private Button COS;/*结果 */private EditText result;private boolean clear_flag;//清空标识 对每个按钮进行实例化并且设置点击事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /* 数字 */ number0 = (Button) findViewById(R.id.number0); number1 = (Button) findViewById(R.id.number1); number2 = (Button) findViewById(R.id.number2); number3 = (Button) findViewById(R.id.number3); number4 = (Button) findViewById(R.id.number4); number5 = (Button) findViewById(R.id.number5); number6 = (Button) findViewById(R.id.number6); number7 = (Button) findViewById(R.id.number7); number8 = (Button) findViewById(R.id.number8); number9 = (Button) findViewById(R.id.number9); /* 运算符 */ add_but = (Button) findViewById(R.id.add_but); sub_but = (Button) findViewById(R.id.sub_but); mult_but = (Button) findViewById(R.id.mult_but); div_but = (Button) findViewById(R.id.div_but); /* 等号 小数点 归零 */ sign_but = (Button) findViewById(R.id.sign_but);//等号 spot_but = (Button) findViewById(R.id.spot_but);//小数点 CE_but = (Button) findViewById(R.id.CE);//归零 DEL = (Button) findViewById(R.id.DEL); SIN=(Button) findViewById(R.id.SIN); COS=(Button) findViewById(R.id.COS); /* 结果 */ result = (EditText) findViewById(R.id.result_Text); /* 初始化事件 */ number0.setOnClickListener(this); number1.setOnClickListener(this); number2.setOnClickListener(this); number3.setOnClickListener(this); number4.setOnClickListener(this); number5.setOnClickListener(this); number6.setOnClickListener(this); number7.setOnClickListener(this); number8.setOnClickListener(this); number9.setOnClickListener(this); add_but.setOnClickListener(this); sub_but.setOnClickListener(this); mult_but.setOnClickListener(this); div_but.setOnClickListener(this); sign_but.setOnClickListener(this); spot_but.setOnClickListener(this); CE_but.setOnClickListener(this); DEL.setOnClickListener(this); SIN.setOnClickListener(this); COS.setOnClickListener(this); &#125; 下面是在onClick方法中实现逻辑运算： 这里使用的方法是使用以下代码获取EditText中的字符串 1String str = result.getText().toString(); 为了区分开数字和运算符，分别用s1、s2和op来表示数字和运算符 123String s1 = exp.substring(0, exp.indexOf(&quot; &quot;));//运算符前面的字符串String op = exp.substring(exp.indexOf(&quot; &quot;) + 1, exp.indexOf(&quot; &quot;) + 2);//截取到的运算符String s2 = exp.substring(exp.indexOf(&quot; &quot;) + 3);//运算符后面的字符串 为了能够实现点击任意按钮可以出现对应的字符，使用以下代码可以获取Button中的内容 1result.setText(str + &quot; &quot; + ((Button) v).getText() + &quot; &quot;); 通过判断出数字和运算符来进行运算，下面是逻辑运算全部的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void getResult() &#123; clear_flag = true; String exp = result.getText().toString(); double result_1 = 0; if(exp==null||exp.equals(&quot;&quot;))&#123; return; &#125; if(!exp.contains(&quot; &quot;))&#123; return; &#125; if (clear_flag)&#123; clear_flag=false; &#125; clear_flag=true; String s1 = exp.substring(0, exp.indexOf(&quot; &quot;));//运算符前面的字符串 String op = exp.substring(exp.indexOf(&quot; &quot;) + 1, exp.indexOf(&quot; &quot;) + 2);//截取到的运算符 String s2 = exp.substring(exp.indexOf(&quot; &quot;) + 3);//运算符后面的字符串 if (!s1.equals(&quot;&quot;) &amp;&amp; !s2.equals(&quot;&quot;)) &#123; double d1 = Double.parseDouble(s1); double d2 = Double.parseDouble(s2); if (op.equals(&quot;+&quot;)) &#123; result_1 = d1 + d2; &#125; else if (op.equals(&quot;-&quot;)) &#123; result_1 = d1 - d2; &#125; else if (op.equals(&quot;*&quot;)) &#123; result_1 = d1 * d2; &#125; else if (op.equals(&quot;/&quot;)) &#123; if (d2 == 0) result_1 = 0; result_1 = d1 / d2; &#125; if (!s1.contains(&quot;.&quot;) &amp;&amp; !s2.contains(&quot;.&quot;)&amp;&amp;!op.equals(&quot;/&quot;)) &#123; int r = (int) result_1; result.setText(r + &quot;&quot;); &#125; else &#123; result.setText(result_1 + &quot;&quot;); &#125; &#125; else if (!s1.equals(&quot;&quot;) &amp;&amp; s2.equals(&quot;&quot;)) &#123; result.setText(exp); &#125; else if (s1.equals(&quot;&quot;) &amp;&amp; !s2.equals(&quot;&quot;)) &#123; double d2 = Double.parseDouble(s2); if (op.equals(&quot;+&quot;)) &#123; result_1 = 0 + d2; &#125; else if (op.equals(&quot;-&quot;)) &#123; result_1 = 0 - d2; &#125; else if (op.equals(&quot;*&quot;)) &#123; result_1 = 0; &#125; else if (op.equals(&quot;/&quot;)) &#123; result_1 = 0; &#125; &#125; else &#123; result.setText(&quot;&quot;); &#125; &#125; 以上便是简单计算器的所有重要代码。 实现功能 支持加减乘除的基本运算 支持加减乘除后的再运算 支持浮点数运算 支持三角函数sin cos运算 支持数字删除 支持置零 随便聊聊第一次写博客，算是大学将尽一个学渣的挣扎，总是要还的，大一不努力，那就现在来补充吧。用hexo和github实现这个博客的搭建还用了差不多一天时间，感谢我河北老乡（名字被马赛克了）的帮助。希望自己能够一直保持热情，加油！]]></content>
      <categories>
        <category>Android编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux SHELL脚本设计]]></title>
    <url>%2F2017%2F12%2F19%2FLinux%20SHELL%E8%84%9A%E6%9C%AC%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Linux SHELL脚本设计 SHELL程序的主要用途 在SHELL程序中不仅仅可以使用命令的集合，而且可而且可以安排自动化处理过程，因此可以通过编写SHELL程序使大量的任务执行实现自动化。SHELL比较擅长完成系统管理任务，尤其适合完成那些易用性、可维护性和便携性比执行效率更优先的任务。 SHELL程序的执行和调试⑴在bash的SHELL程序设计中，程序必须以下面的行开始： ​ #！/bin/bash 这里符号#！用来告诉系统，后面给出的参数是用来执行该文件的程序。 ⑵当编辑完一个SHELL脚本后，要使该脚本能够执行，还必须使该脚本文件具有可执行权。需要执行命令：chmod +x filename ⑶在shell程序中，以#开头到一个行结束的句子表示注释信息。建议大家在编写shell程序时养成添加注释的习惯，因为注释不仅能给其他需要熟悉悉该程序的人以帮助，也能给出脚本编写者设计原理的提示。 ⑷进行shell程序设计时，必定会用到变量。Shell编程中使用的变量有自己的特色，即所有的变量都是由字符串组成的，而且对变量无须进行声明，可直接进行变量赋值操作。 程序设计1.创建以下菜单程序USER:** HOST: ** DATE: xx/xx/20xx A: 创建子目录并复制文件 B: 文件权限测试 C: 文件字符转换 D: 文件总数及文本行数统计 E: 文件查找 Q: 退出系统 ——————————————————————————————— A：在用户家目录下创建名字为本人姓名的子目录，其存取权限为(drwxr-xr-x)。测试目录确实存在后，将已存在的file1、file2两文件拷入其中并分别显示两文件的内容。显示完成后将file1、file2两文件截断为大小为0的空文件。 B：测试当前用户对系统中某文件是否有r、w、x的权限，输出测试结果。 C：将file1、file2两文件中的小写字符转换为大写，并将转换后的内容分别写入新文件。判断上述操作成功后分别显示转换后的新文件的内容。 D：统计/dev目录下目录文件和符号链接文件的数目；统计系统中某文本文件中空行的行数；显示当前系统中所有环境变量。 E：在/dev目录下查找由s开头且文件名由5个字符组成的文件，找到后用file命令显示其文件类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/bin/bashUSER= &apos;whoami&apos;HOST=`hostname -s`MYDATE=`date +%d/%m/%y`while :doclearcat &lt;&lt; MAYDAY----------------------------------------------------------------- User:$USER Host:$HOST Date:$MYDATE----------------------------------------------------------------- A:创建子目录并复制文件 B:文件权限测试 C:文件字符转换 D:文件总数及文本行数统计 E:文件查找 Q:退出系统------------------------------------------------------------------MAYDAYecho -n &quot;Please Choose [A,B,C,D,E,Q]&gt;&quot;read CHOICEcase $CHOICE inA)echo &quot;A:创建子目录并复制文件&quot;echo &quot;输入要创建的文件名:&quot;read FILEmkdir $FILEchmod 755 $FILEtest -d $FILEif [ $? -eq 0 ]thencp file1 $FILEcp file2 $FILEecho &quot;file1 内容&quot;cat file1:&gt;$FILE/file1echo &quot;file2 内容&quot;cat file2:&gt;$FILE/file2fi;;B)echo &quot;B:文件权限测试&quot;echo &quot;请输入要测试的文件绝对路径&quot;read NAME1test -r $NAME1if [ $? -eq 0 ]thenecho &quot;可读&quot;elseecho &quot;不可读&quot;fitest -w $NAME1if [ $? -eq 0 ]thenecho &quot;可写&quot;elseecho &quot;不可写&quot;fitest -x $NAME1if [ $? -eq 0 ]thenecho &quot;可执行&quot;elseecho &quot;不可执行&quot;fi;;C)echo &quot;C:文件字符转换&quot;cat file1 | tr &quot;[a-z]&quot; &quot;[A-Z]&quot; &gt;file1.trdiff -q file1 file1.trif [ $? -eq 1 ]thenecho &quot;file1.tr 内容&quot;cat file1.trficat file2 | tr &quot;[a-z]&quot; &quot;[A-Z]&quot; &gt;file2.trdiff -q file2 file2.trif [ $? -eq 1 ]thenecho &quot;file2.tr 内容&quot;cat file2.trfi;;D)echo &quot;/dev 目录下目录文件和符号链接文件的数目&quot;find /dev -type d | wc -lfind /dev -type l | wc -lecho &quot;file1 空行行数统计&quot;grep ^$ file1 | wc -lecho &quot;显示当前系统中所有环境变量&quot;env;;E)echo &quot;文件查找&quot;find /dev -name &apos;s????&apos; | xargs file;;Q)exit 0;;*)echo &quot;输入不符合条件！请回车后输入[A.B.C.D.E.Q]&quot;esacread DDdone 2.文件pc.txt中保存了三个班级的学生选课成绩试编写一段shell程序对文件内容进行统计、计算后输出各个班级选课的学生人数及每班选课成绩的优秀率。 pc.txt 文件内容 如下： Student1: 1301: 75 Student2: 1302: 96 Student3: 1303: 99 Student4: 1302: 93 Student5: 1303: 23 Student6: 1301: 77 1234567891011121314151617#!/bin/bashtotal1=`grep -F 1301 pc.txt|wc -l`gradeA1=`grep -F 1301 pc.txt|awk -F： &apos;$3 &gt; 90&apos;|wc -l`rateA1=$(($gradeA1*100/$total1))total2=`grep -F 1302 pc.txt|wc -l`gradeA2=`grep -F 1302 pc.txt|awk -F： &apos;$3 &gt; 90&apos;|wc -l`rateA2=$(($gradeA2*100/$total2))total3=`grep -F 1303 pc.txt|wc -l`gradeA3=`grep -F 1303 pc.txt|awk -F： &apos;$3 &gt; 90&apos;|wc -l`rateA3=$(($gradeA3*100/$total3))echo &quot;各班选课人数及优秀率（90及以上为优秀）&quot;echo &quot;1301班选课人数为$total1,优秀率为$rateA1%&quot;echo &quot;1302班选课人数为$total2,优秀率为$rateA2%&quot;echo &quot;1303班选课人数为$total3,优秀率为$rateA3%&quot; 3.学习、理解find和grep(家族)命令编制两个个性化的文件搜索工具。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/bin/bashecho &quot;个性化文件搜索工具:&quot;echo &quot;1:grep搜索工具&quot;echo &quot;2:find搜索工具&quot;echo &quot;选择想要使用的工具[1|2]:&quot;read CHOICEif [ &quot;$CHOICE&quot; == &quot;1&quot; ] #选择grepthenecho &quot;自定义查找&quot;echo &quot;请输入查找目录:&quot;read mululs $mulu &gt; mulu.txtecho &quot;1:查找以匹配模式开头的文件&quot;echo &quot;2:查找不包含匹配模式的文件&quot;echo &quot;3:查找以匹配模式结尾并且长度固定的文件&quot;read CHOICE1case $CHOICE1 in 1)echo &quot;查找以匹配模式开头的文件&quot; read scanf grep -E ^$scanf mulu.txt;; 2)echo &quot;查找不包含匹配模式的文件&quot; read scanf grep -Ev $scanf mulu.txt;; 3)echo &quot;查找以匹配模式结尾并且长度固定的文件&quot; read scanf echo &quot;请输入长度&quot; read length readlength=$(($length-`echo $&#123;#scanf&#125;`)) grep -xE [[:alnum:]]\&#123;$readlength\&#125;$scanf mulu.txt;; *)esacelse #选择findecho &quot;自定义查找&quot;echo &quot;请输入查找目录:&quot;read mulu2echo &quot;1:查找文件大小大于给定下限的文件&quot;echo &quot;2:查找给定时间内修改过的文件&quot;echo &quot;3:查找给定文件后缀的文件&quot;read CHOICE2case $CHOICE2 in 1)echo &quot;请输入文件大小下限值(k)&quot; read size find $mulu2 -size +$size ;; 2)echo &quot;请输入时间(day)&quot; read time find $mulu2 -mtime +$time ;; 3)echo &quot;请输入文件后缀&quot; read houzhui find $mulu2 -name *.$houzhui;; *)esacfiread DD]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下目录及其操作命令]]></title>
    <url>%2F2017%2F12%2F17%2FLinux%E4%B8%8B%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux下目录及其操作命令 创建和删除目录的命令mkdir命令用来创建目录。 -m, –more=MORE 将新建目录的存取权限设置为MORE,存取权限用给定的八进制数字表示。 -p, –panrents 可一次性建立多个目录，即如果新建目录所指定的路径中有些父目录尚不存在，此选项可以自动建立他们。 12$ mkdir --more=700 /home/mengqc/test (在目录/home/mengqc下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问)$ mkdir -p -m 750 bin/os_1 (在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写执行，用户组可读和执行，其他用户无权访问) rmdir命令从一个目录中删除一个或多个空的子目录。 -p –parents 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果有非空目录，则该目录保留下来。 12$ cd /home/mengqc/testrmdir -p bin/os_1 (删除子目录os_1和其父目录bin) 改变工作目录和显示目录内容的命令cd命令改变工作目录。 123$ cd /home/liu (将当前目录改到/home/liu)$ cd (将当前目录改到用户的主目录)$ cd ../.. (将当前目录向上移动两级) pwd命令显示当前工作目录的绝对路径。 12$ pwd/home/mengqc ls命令列出指定目录的内容。 -a, –all 显示指定目录下所有子目录和文件，包括”.”开头的隐藏文件（例如.cshrc）。 -A, –almost-all 显示指定目录下所有子目录和文件，包括”.”开头的隐藏文件，但是列出”.”和”..”目录项 -b, –escape 当文件名中包含不可显示的字符时，则用\ddd（3位八进制数）形式显示该字符。 -c 按文件的修改时间排序 -C 分成多列显示项目 -d 如果参数是目录，则只显示它的名字，往往与-l选项一起用，以得到目录的详细信息。 -i, –inode 在输出的第一行显示文件的I节点号。 1234$ ls -F (列出当前目录的内容，并标出文件的属性)Desktop/ ex1 ex2 m1.c m2.c test/$ ls -C /home/mengqc (按多列形式列出目录/home/mengqc的内容)$ ls -lai (以长列表格式列出当前目录的内容，包含隐藏文件和他们的I节点号) 链接文件的命令硬链接建立硬链接时，在别的目录或者本目录中增加目标文件的一个目录项，这样一个文件就登记在多个目录中。创建硬链接后，已经存在的文件的I节点号（Inode）会被多个目录文件项使用。 对硬链接有如下限制： ①不能对目录文件创建硬链接。 ②不能在不同的文件系统之间创建硬链接。就是说链接文件和被链接文件必须位于同一个文件系统中。 符号链接符号链接也称为软链接，是将一个路径名链接到另一个文件。这些文件是一种特别类型的文件。事实上，他只是一个文本文件，其中包含了它提供链接的另一个文件的路径名，另一个文件是实际包含所有数据的文件。所有读写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。 ln命令用来创建链接。 -s, –symbolic 建立符号链接，而不是硬链接。 123$ cd /home/mengqc$ ln mub1/m2.c /home/liu/a2.c (将目录/home/mengqc/mub1下的文件m2.c链接到目录/home/liu下的文件a2.c)$ ln -s /home/mengqc/mub1 /home/liu/abc (在目录/home/liu下建立一个符号链接文件abc，使他指向目录/home/mengqc/mub1) 改变文件或目录存取权限的命令用户权限（1）文件主 Linux为每个文件都分配一个文件所有者，成为文件主，并赋予文件主唯一的注册名。对文件的控制取决于文件主或超级用户（root） 文件或目录的创建者对创建的文件或目录拥有特别使用权。 文件的所有关系是可以改变的，可以将文件或目录的所有权转让给其他用户，但只有文件主或者超级用户才有权改变文件的所有关系。文件所有权的标志是用户ID(UID). （2）用户组 当系统给管理员为用户建立账号后，会分配一个组ID合一个特定的用户组名。 （3）存取权限 Linux系统中的每个文件和目录都有存取许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 Linux系统规定了4中不同类型的用户：①文件主（owner）②同组用户（group）③可以访问系统的其他用户（others）④超级用户（root） 存取权限规定了3中访问文件或者目录的方式：①读（r）②写（w）③可执行或查询（x）。 chmod命令用于改变或者设置文件或目录的存取权限。 一般格式：chmod key 文件名 key：who 操作符号 mode [who]: u 用户（user），即文件或目录的所有者 g 同组（group）用户，即与文件属主有相同组ID的所有用户 o 其他（others）用户， a 所有（all）用户。他是系统默认值 [操作符号]: +添加某个权限 -取消某个权限 =赋予给定权限并取消原有权限 [mode]: r 可读 w 可写 x 可执行 123$ chmod a+x ex1 (将文件ex1的权限改为所有用户都有执行权限)$ chmod u=r ug=x ex1 （将ex1的权限诚信设置成文件主可以读和执行，组用户可以执行，其他用户无权限）$ chmod 0664 ex1 (使文件ex1的文件主和同组用户具有读、写权限，而其他用户只可读) umask命令用来设置限制新建文件权限的掩码。 1$ umask u=,g=w,o=rwxg (将组用户的写权限、其他用户的读/写和执行权限都取消) 改变用户组和文件主的命令chgrp命令改变文件或目录的所属的用户组。 -R，–recursive 递归式改变指定目录及其下面的所有子目录和文件的用户组。 1$ chgrp -R mengxin /home/mengqc (将/home/mengqc及其子目录下的所有文件的用户组改为mengxin) chown命令改变某个文件或目录的所有者和所属的组。 -R，–recursive 递归式改变指定目录及其下面的所有子目录和文件的文件主。 -v –verbose 详细列出该命令所做的工作。 ps：只有文件主和超级用户可以使用该命令。 1$ chown -R liu /home/mengqc (将目录/home/mengqc及下面的所有文件、子目录的文件主改为liu)]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下文件操作命令]]></title>
    <url>%2F2017%2F12%2F15%2FLinux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux下文件操作命令 文件显示命令cat命令链接文件并打印到标准输出设备上，cat经常用来显示文件的内容。 123$ cat m1 (在屏幕上显示文件m1的内容)$ cat m1 m2 (同时显示文件m1和m2的内容)$ cat m1 m2&gt;mfile (将m1和m2合并后放入文件mfile中) more命令显示文件内容，每次显示一屏。 -num 显示多少行 -c或者-p 显示前清屏 -s 将文件中空白行压缩成一个空白行显示 +num 从行号num开始 12$ more -dc mfile //显示文件内容，显示前先清屏，并在屏幕下方显示完整的百分比$ more -c -10 mfile //显示mfile文件的内容，每10行显示一次，显示前清屏 head命令在屏幕上显示指定文件的开头若干行。 123$ head -5 mfile (显示mfile前5行)$ head -v mfile (显示文件mfile的内容，并且给出文件名标题)$ head -q mfile (显示文件mifile的内容，但不列出文件名标题) tail命令在屏幕上显示指定文件的末尾若干行。 123$ tail mfile (显示文件mfile的最后10行)$ tail +20 mfile (显示文件mfile的内容，从第二十行至文件末尾)$ tail -c 10 mfile (显示文件mfile的最后10个字符) 匹配、排序及显示指定内容的命令grep命令1234$ grep -F mengqc /etc/passwd (在密码文件/etc/passwd中查找包含mengqc的所有行)$ grep -r &apos;print&apos; mengqc (在mengqc目录下和子目录下的所有文件中查找字符串print出现的次数)$ grep -E &apos;[Mm]ain|[Pp]rintf&apos; f1 f2 (在文件f1和f2中查找包含main或printf的所有行，不区分首字母大小写)$ grep -i &apos;main|printf&apos; (同上) sort命令对文本文件的各行进行排序。 1$ sort more_h10 (对more_h10文件排序) uniq命令从排好序的文件中去除重复行。 123$ uniq -u ex3 (显示文件ex3中不重复的行)$ uniq -d ex3 (只显示文件ex3中重复的行)$ uniq -c ex3 (显示输出时，在每行的首位加上该行在文件中出现的次数) 比较文件内容的命令comm命令对两个已经排序文件进行逐行比较。 1$ comm -12 m1 m2 （比较m1和m2，并且只显示他们共有的行） diff命令比较两个文本文件，并找出他们的不同，而且不用预先排序。 -b 忽略空格造成的差别。 比如”How are you”和”How are you”被看做相同字符。 -i 忽略字母大小的区别。 -r 当文件1和文件2都是目录的时候，递归比较找到各自的子目录。 复制、删除和移动文件的命令cp命令将源文件或者目录复制到目标文件或目录中。 123$ cp mfile /home/mengqc/exam1 (复制到/home/mengqc目录下，并改名为exam1)$ cp -r /home/mengqc /home/liuzh (将目录/home/mengqc下的所有文件以及子目录复制到/home/liuzh目录中)$ cp -i /home/mengqc/m*.c .home/liuzh (将目录/home/mengqc下的所有.c文件复制到/home/liuzh目录中) rm命令删除文件和目录。 1234$ rm -i test example (交互式删除当前目录下的文件test和example)rm：是否删除一般文件‘test’？n (不删除)rm: 是否删除一般文件‘example’？y （删除）$ rm -r * (删除目录下除隐含文件外的所有文件和子目录) mv命令对文件或目录重新命名，或者将文件从一个目录转移到另一个目录。 12$ mv ex3 new1 (将文件ex3改名为new1)$ mv /home/mengqc/* . (将目录/home/mengqc中的所有文件移到当前目录（用“.”表示）) 文件内容统计命令wc命令统计指定文件的字节数、字数、行数，并将统计结果显示出来。 -c, –bytes 统计字节数 -l, –line 统计行数 -w, –words 统计字数 12$ wc -lcw ex1 ex2 (统计文件ex1和文件ex2的字节数、字数和行数)$ wc ex1 ex2 (不带选项，统计文件ex1和ex2的字节数、字数和行数) 上面两种情况，执行结果一样。]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2017%2F12%2F13%2F%E5%8D%9A%E5%AE%A2%E6%96%BD%E5%B7%A5%E7%BB%93%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[博客施工结束 博客创建创建过程1.安装Node.js并配置好Node.js环境，通过cmd输入“node -v”和“npm -v”可验证。 12345C:\User\马里奥&gt;node -vv6.11.4C:\User\马里奥&gt;npm -v5.4.2 2.安装Git并配置好Git环境，安装成功的后，在电脑任何位置，鼠标右键出现“Git GUI Here”和“Git Bash Here”即成功。 3.注册Github并且新建一个仓库，仓库名称严格按照“账户名.github.io”来设置，同时勾选Initialize this repository with a README。 4.接下来便是安装hexo，提一嘴路径的问题，包括以上的所有安装都是自定义路径，然后在cmd中通过cd命令进入要安装的文件夹，使用“npm install hexo -g“命令进行安装，这时候静静的等待就好了。 1D:\blog&gt;npm install hexo -g 可以使用”hexo -v”命令检查是否安装成功，出现一大堆类似于版本号的东西就成功了。 1D:\blog&gt;hexo -v 5.同样是在这个文件夹的路径下，cmd中使用“hexo init”命令进行文件夹的初始化，也是需要静静等待的。当出现“Start blogging with Hexo”的时候，这一阶段就告一段落了。 1D:\blog&gt;hexo init 6.同样是在这个文件夹的路径下，cmd中使用“npm install”安装所需的组件。 1D:\blog&gt;npm install 7.组件安装成功后，这时候可以首次体验一下Hexo了，输入“hexo g”。然后在输入“hexo s”开启服务器，访问网址。 123D:\blog&gt;hexo gD:\blog&gt;hexo s 8.终于快要完成了，现在便是将Hexo和 Github page联系起来，使用Git bash设置Git的user name和email（在我设置的blog路径下，可以直接在这个文件夹里面鼠标右键选择Git Bash Here）。 1$ git config --global user.name &quot;maliao&quot; 1$ git config --global user.email &quot;xxxx@xx.com&quot; 9.选择C:\Users\Administrator.ssh路径下鼠标右键选择Git Bash Here，输入“ssh-keygen -t rsa -C “xxxx@xx.com“”,连续三个回车以后，生成秘钥，得到两个文件：id_rsa和id_rsa.pub。输入“eval “$(ssh-agent -s)””,添加密钥到ssh-agent，再输入ssh-add ~/.ssh/id_rsa，添加生成的SH key到ssh-agent 1$ sh-keygen -t rsa -C &quot;xxxx@xx.com 1$ eval &quot;$(ssh-agent -s)&quot; 1$ ssh-add ~/.ssh/id_rsa 10.登录Github，点击个人头像里的settings添加ssh。点击左边的SSH and GPG keys，然后选择New SSH key，将id_rsa.pub内容复制上去。在Git bash中输入“ssh -T git@github.com”，测试添加ssh是否成功。如果出现“Hi 你的用户名”，恭喜你，添加成功！ 11.在blog文件夹中找到_config.yml文件，修改repo值，注意：空格。 1234deploy： type: git repository: git@github.com:maliao/maliao.github.io.git branch: master 12.搭建完成，执行hexo new post “博客名”新建一篇博客，（发布文章之前使用npm install hexo-deployer-git –save命令安装一个必要拓展）通过编辑器编辑好文章后，执行hexo d -g命令，你的第一篇博客便发出了。 搭建过程中的一些坑1.Node.js在安装的过程中会自动配置环境。 2.官网下载Git非常慢，可以选择其他方式。 3安装Hexo的过程很慢，而且可能会停在某处，不要试图去打扰他，静静地等待就好了。 4.本地访问Hexo时候，Ctrl+C和你平时用的复制键是一个，所以要注意，不要复制了网址，Hexo却stop了。 5.在你测试添加ssh是否成功的时候，她可能出现一个很迷的选项让你选择（YES/NO）,跟教程不太一样，这时候，你要果断选择YES。 6.新版本Git，配置Deployment时候，不要试图去修改type后的git为github。 7.再次部署文章的时候，记得先使用“hexo clean”命令，不然你会体会到什么叫佛。]]></content>
      <categories>
        <category>博客杂谈</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
