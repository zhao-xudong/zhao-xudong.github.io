<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关键字this引用]]></title>
    <url>%2F2018%2F04%2F16%2Fthis%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关键字this引用 要点提示：关键字this引用独享自身。他也可以在构造方法内部调用另一个类的其他构造方法。 ​ 关键字this是指向调用对象本身的引用名。可以用this关键字引用对象的实例成员。 例如：下面a的代码使用this来显示地引用独享的radius以及调用他的getArea()方法。this引用通常可以省略掉的，如b所示。然而，在引用隐藏数据域的以及调用一个重载的构造方法的时候，this引用是必须的。 12345678910111213141516171819202122//a:public class Circle&#123; private double radius; ..... public double getArea() &#123; return this.radius*this.radius*Math.PI; &#125; public String toString() &#123; return &quot;radius&quot;+this.radius+&quot;area&quot;+this.getArea(); &#125;&#125;//b:public class Circle&#123; private double radius; ..... public double getArea() &#123; return radius*radius*Math.PI; &#125; public String toString() &#123; return &quot;radius&quot;+radius+&quot;area&quot;+getArea(); &#125;&#125; 使用this引用隐藏数据域​ this关键字可以用于引用类的隐藏数据域。例如在数据域set方法中，经常将数据域名用作参数名。在这种情况下，这个数据域在set方法中被隐藏。为了给他设置新值，需要在方法中引用隐藏的数据域名。隐藏的静态变量可以简单的通过“类名.静态变量”的方式引用。隐藏的实例变量就需要使用关键字this来引用了。 1234567891011public class F &#123; private int i = 5; private static double k = 0; public void setI(int i)&#123; this.i = i; &#125; public static void setK(double k) &#123; F.k = k; &#125; //other menthods omitted&#125; 使用this调用构造方法​ 关键字this可以用于调用同一个类的另一个构造方法。例如，可以如下改写Circle类： 123456789public class Circle &#123; private double radius; public Circle(double radius) &#123; tihs.radius = radius; //this关键字用于引用所构建的对象的隐藏数据radius &#125; public Circle() &#123; tihs(1.0); //this关键字用来调用另一个构造方法 &#125;&#125; ​ 在第二个构造方法中，this(1.0)这一行调用带double值参数的第一个构造方法。 注意：Java要求在构造方法中，语句this(参数列表)应在任何其他可执行语句之前出现。 提示：如果一个类有多个构造方法，最好尽可能的使this(参数列表)实现它们。通常，无参数或参数少的构造方法可以用this(参数列表)调用参数多德构造方法。这样做通常可以简化代码，使类便于阅读和维护。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java库中的Point2D类]]></title>
    <url>%2F2018%2F04%2F15%2FJava%E5%BA%93%E4%B8%AD%E7%9A%84Point2D%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java库中的Point2D类 javafx.geometry.Point2D +Point2D(x: double,y: double) //用给定的x和y坐标来创建一个Point2D对象 +distance(x: double,y: double): double //返回该点到定点（x,y）的距离 +distance(p: Point2D): double //返回该点到p点的距离 +getX(): double //返回该点的x的坐标 +getY(): double //返回该点的y的坐标 +toString(): String //返回该点的字符串表示 12345678910111213141516171819import java.util.Scanner;import javafx.geometry.Point2D;public class TestPoint2D &#123;public static void main(String[] args)&#123; Scanner input= new Scanner(System.in); System.out.println(&quot;Enter point1&apos;s x-,y-coordinates:&quot;); double x1=input.nextDouble(); double y1=input.nextDouble(); System.out.println(&quot;Enter point2&apos;s x-,y-coordinates:&quot;); double x2=input.nextDouble(); double y2=input.nextDouble(); Point2D p1 =new Point2D(x1,y1); Point2D p2 =new Point2D(x2,y2); System.out.println(&quot;p1 is&quot;+p1.toString()); System.out.println(&quot;p2 is&quot;+p2.toString()); System.out.println(&quot;distance is&quot;+p1.distance(p2)); &#125; &#125; 为什么会把这个类单拿出来呢，因为在eclipse运行的时候，你会发现会报错，难道是书写错了？不不不，下面是答案： 这是因为这个类是Eclipse的JRE带的，但并不属于JAVA的公开API。解决方法：右击项目-&gt;属性-&gt;Java Compiler-&gt;Errors/Warnings-&gt;Deprecated and restricted API-&gt;Forbidden reference -&gt; Ignore 运行结果 1234567Enter point1&apos;s x-,y-coordinates:1 2Enter point2&apos;s x-,y-coordinates:3 4p1 isPoint2D [x = 1.0, y = 2.0]p2 isPoint2D [x = 3.0, y = 4.0]distance is2.8284271247461903]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Java库中的类]]></title>
    <url>%2F2018%2F04%2F15%2F%E4%BD%BF%E7%94%A8Java%E5%BA%93%E4%B8%AD%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[使用Java库中的类 Date类java.util.Date +Date() //为当前时间创建一个Date对象 +Date(elapseTime: long)//为一个从格林威治时间1970年1月1日至今流逝的以毫秒为单位计算的给定时间创建的Date对象 +toString(): String //返回一个代表日期和时间的字符串表示 +getTime(): long //返回从格林威治时间1970年1月1日至今流逝的毫秒数 +setTime(elapseTime: long): void //在对象中设置一个新的流逝时间 123456java.util.Date date = new java.util.Date();System.out.println(&quot;The elapsed time since Jan 1,1970 is&quot;+date.getTime()+&quot;milliseconds&quot;);System.out.println(date.toString());//输出：The elapsed time since Jan 1,1970 is1523760077427millisecondsSun Apr 15 10:41:17 CST 2018 Random类java.util.Random +Random() //以当前时间创建一个Random对象 +Random(seed: long) //以一个特定的值作为种子创建一个Random对象 +nextInt(): int //返回一个随机的int值 +nextInt(n: int): int //返回一个0到n之间的随机int类型的数 +nextLong(): long //返回一个0到n之间的随机long值 +nextDouble(): double //返回一个0.0到1.0（不包含1.0）之间的随机double类型的值 +nextFloat(): float //返回一个0.0F到1.0F（不包含1.0F）之间的随机float类型的值 123456789101112131415161718192021java.util.Random random1 = new java.util.Random(3);System.out.println(&quot;From random1:&quot;);for(int i=0;i&lt;10;i++) System.out.print(random1.nextInt(1000)+&quot; &quot;); java.util.Random random2 = new java.util.Random(3);System.out.println(&quot;\nFrom random2:&quot;);for(int i=0;i&lt;10;i++) System.out.print(random2.nextInt(1000)+&quot; &quot;); java.util.Random random3 = new java.util.Random();System.out.println(&quot;\nFrom random3:&quot;);for(int i=0;i&lt;10;i++) System.out.print(random3.nextInt(1000)+&quot; &quot;);//输出：From random1:734 660 210 581 128 202 549 564 459 961 From random2:734 660 210 581 128 202 549 564 459 961 From random3:384 412 586 796 729 521 52 718 586 355 还有一个类，我们在下一篇文章介绍，有一点特殊。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类多文件运行]]></title>
    <url>%2F2018%2F04%2F14%2FJava%E7%B1%BB%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[Java类多文件运行 TV类对电视机的建模：​ channel: int //这个TV的当前频道（从1到120） ​ volumeLevel: int //这个TV的当前音量（从1到7） ​ on: boolean //表明这个TV是开的还是关的 ​ +TV() //构造一个默认的TV对象 ​ +turnOn(): void //打开这个TV ​ +turnOff(): void //关闭这个TV ​ +setChannel(newChannel: int): void //为这个TV设置一个新频道 ​ +setVolume(newVolumeLevel: int): void //为这个TV设置一个新音量 ​ +channelUp(): void //给频道数+1 ​ +channelDown(): void //给频道数-1 ​ +volumeUp(): void //给音量+1 ​ +volumeDown:void //给音量-1 TV.java文件TV类中的构造方法定义为公共的，因此可以从其他类中访问。 123456789101112131415161718192021222324252627282930313233343536public class TV &#123; int channel = 1; int volumeLevel = 1; boolean on = false; public void turnOn()&#123;//开 on = true; &#125; public void turnOff()&#123;//关 on = false; &#125; public void setChannel(int newChannel)&#123; if(on &amp;&amp; newChannel &gt;= 1&amp;&amp; newChannel &lt;= 120) volumeLevel = newChannel; &#125; public void setVolume(int newVolumeLevel)&#123; if(on &amp;&amp; newVolumeLevel &gt;=1 &amp;&amp; newVolumeLevel &lt;=7) volumeLevel = newVolumeLevel; &#125; public void channelUp()&#123; if(on &amp;&amp; channel &lt; 120) channel++; &#125; public void channelDown()&#123; if (on &amp;&amp; channel &gt; 1) channel--; &#125; public void volumeUp()&#123; if(on &amp;&amp; volumeLevel &lt; 7) volumeLevel++; &#125; public void volumeDown()&#123; if(on &amp;&amp; volumeLevel &gt; 1) volumeLevel--; &#125;&#125; TestTV.java文件第3行和第8行创建了两个对象，然后调用对象中的方法来完成设置频道和音量的动作。 12345678910111213141516public class TestTV &#123; public static void main(String[] args)&#123; TV tv1 = new TV(); tv1.turnOn();//tv1 开 tv1.setChannel(30);//频道 30 tv1.setVolume(3);// 音量 3 TV tv2 = new TV(); tv2.turnOn();// tv2 开 tv2.channelUp();// tv2 频道+1 tv2.volumeUp();//tv2 音量+1 System.out.println(&quot;tv1的频道是&quot;+tv1.channel+&quot;声音是&quot;+tv1.volumeLevel); System.out.println(&quot;tv2的频道是&quot;+tv2.channel+&quot;声音是&quot;+tv2.volumeLevel); &#125;&#125; 运行结果12tv1的频道是1声音是3tv2的频道是2声音是2]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客添加搜索功能]]></title>
    <url>%2F2018%2F04%2F13%2Fhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[hexo博客添加搜索功能 前言 当博文慢慢变多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博客上去，所以添加一个本站内搜索功能是很有必要的。 安装插件直接在自己的博客文件夹下（我的是blog）点击鼠标右键选择Git Bash Here 1npm install hexo-generator-searchdb --save 修改站点配置文件我的路径是：blog下的_config.yml文件，进行编辑。 12345search： path: search.xml field: post format: html limit: 10000 PS:每个冒号后面都有空格。 修改主题配置文件我的路径：/blog/themes/next下的_config.yml文件，进行编辑。 12local_search: enable: true PS:冒号后面都有空格。 此时，部署到github，打开网页就可以看到搜索功能了，容易添加，使用起来很方便，推荐添加，增加网站友好度。]]></content>
      <categories>
        <category>博客杂谈</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客添加评论神器---valine]]></title>
    <url>%2F2018%2F04%2F12%2Fhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%A5%9E%E5%99%A8---valine%2F</url>
    <content type="text"><![CDATA[hexo博客添加评论神器—valine 我们评论系统是放在LeanCloud上的，因此需要先去注册一个账号。 LeanCloud官网，点击注册 注册完成后需要创建一个应用，创建成功以后，进入应用→设置→应用key 获取到了你的appid和appkey 1234567App IDXXXXXXXXXXXXXXXXXXXXXXXXXX每个app有一个唯一的ID，不可变更App KeyXXXXXXXXXXXXXXXXXXXXXXXXXX适用于所有平台 拥有了你的appid和appkey后，打开主题配置文件（blog/themes/next/_config.yml）填写appid和appkey 123456789valine： enable: true appid: your app id //你获取的appid appkey your app key //你获取的app key notifiy: false # mail notifier,https://github.com/xCss/Valine/wiki //是否开启邮箱提醒 verfify: false # Verifaication code //开启验证码 planceholde: 评论内容。 //你要发表的评论内容 guest_info: nick,mail,link pageSize: 10 PS：配置的时候自行删除”//“开始以后的注释内容，同时如果开启邮箱提醒的话，会默认开启验证码模式。 完成这些以后还需要在LeanCloud中，进入应用→设置→安全中心在Web 安全域名中填写自己的博客首页，然后保存。 最后部署到github，打开自己的博客就可以看到评论功能，有没有点小激动，快去邀请小伙伴发表评论吧。]]></content>
      <categories>
        <category>博客杂谈</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器的设计与实现]]></title>
    <url>%2F2018%2F04%2F11%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[词法分析器的设计与实现 词法分析器介绍 词法分析是从左到右扫描每行源程序的符号，拼成单词，换成统一的机内表示形式——TOKEN字，送给语法分析程序。 TOKEN字是一个二元式：（单词种别码，自身值）。单词自身值按如下规则给出： ​ 1.标识符的自身值是他在符号表的入口位置。 ​ 2.常数的自身值是常数本身（或者其他二进制数值）。 ​ 3.关键字和界限符的自身值为本身。 词法分析器功能1.输入：字符串（带进行词法分析的源程序），可从键盘直接输入或从文件读入。 输出：由（种别码，自身值）所组成的二元组序列。 单词的种别码是语法分析需要的信息，可用整数编码表示，例如：标识符的种别码为1，常数为2，保留字为3，运算符为4，界符为5。 单词的自身值是编译其他阶段需要的信息，标识符的自身是标识符在符号表入口，其他类型单词的自身值是其本身。 例如：输入：if i &gt;= 15 then x := y ; ​ 输出： ​ （3，if） ​ （1，0）//i符号的入口为0 ​ （4，&gt;=） ​ （2，15） ​ （3，then） ​ （1，1）//x符号的入口为1 ​ （4，：=） ​ （1，2）//y符号的入口为2 ​ （5，；） 2.功能： a.滤过空格。 b.识别保留字：if then else while do 等。 c.识别标识符：&lt;字母&gt;(&lt;字母&gt;|&lt;数字&gt;)。 d.识别整数：0|(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)。 e.识别典型的运算符和分隔符，例如：+ - * / &gt; &gt;= &lt;= ( ) ; 3.具有一定的错误处理功能，例如：能检查出程序语言的字符集以外的非法字符。 源码附带注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;string&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;bool isLetter(char ch)&#123;//isLetter 标识符 if ((ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) || (ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;)) return true; else return false;&#125;bool isDigit(char ch)&#123;//isDigit 常数 if (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) return true; else return false;&#125;bool isOperators(char ch)&#123;// isOperators 运算符 if (ch == &apos;+&apos; || ch == &apos;*&apos; || ch == &apos;-&apos; || ch == &apos;/&apos; || ch == &apos;=&apos; || ch == &apos;:&apos; || ch == &apos;&lt;&apos; || ch == &apos;&gt;&apos;) return true; else return false;&#125;bool isDelimiter(char ch)&#123;// isDelimiter 界符 if (ch == &apos;,&apos; || ch == &apos;;&apos; || ch == &apos;.&apos; || ch == &apos;(&apos; || ch == &apos;)&apos; || ch == &apos;[&apos; || ch == &apos;]&apos; || ch == &apos;&#123;&apos; || ch == &apos;&#125;&apos; || ch == &apos;#&apos;) return true; else return false;&#125;bool isBlank(char ch)&#123; if (ch == &apos; &apos; || ch == &apos;\t&apos;) return true; else return false;&#125;char key[34][10] = &#123; &quot;main&quot;,&quot;auto&quot;, &quot;short&quot;, &quot;int&quot;, &quot;long&quot;, &quot;float&quot;, &quot;double&quot;, &quot;char&quot;, &quot;struct&quot;, &quot;union&quot;, &quot;enum&quot;, &quot;typedef&quot;, &quot;const&quot;, &quot;unsigned&quot;, &quot;signed&quot;, &quot;extern&quot;, &quot;register&quot;, &quot;static&quot;, &quot;volatile&quot;, &quot;void&quot;, &quot;if&quot;, &quot;else&quot;, &quot;switch&quot;, &quot;case&quot;, &quot;for&quot;, &quot;do&quot;, &quot;while&quot;, &quot;goto&quot;, &quot;continue&quot;, &quot;break&quot;, &quot;default&quot;, &quot;sizeof&quot;, &quot;return&quot;,&quot;then&quot;&#125;;void main()&#123;back: char Sourcecode[100] = &quot;&quot;; int number=0; int h=0; char hh[100][10]=&#123;&apos;\0&apos;&#125;; //声明变量 printf(&quot;请输入程序段，标识符为1，常数为2，关键字为3，运算符4，界符5\n&quot;); gets(Sourcecode); //读入程序段放入firstcode for (int i = 0; i &lt; 100; i)&#123; //char delimiter[2] = &quot;&quot;; int j = 0; //letter 标识符 int l = 0; //digit 常数 int k = 0; //operators 运算符 int b = 0; //类型编号 char num[10] = &quot;&quot;; char word[10] = &quot;&quot;; if (isBlank(Sourcecode[i]) == 1)&#123; i += 1; &#125;//去空格 else&#123; if (isLetter(Sourcecode[i]) == 1) //是否为字母 &#123; //是 do &#123; if (j &lt; 10)&#123; word[j] = Sourcecode[i]; j++; &#125; &#125; while (isDigit(Sourcecode[++i]) == 1|| isLetter(Sourcecode[i]) == 1);//常数||标识符 //*~~~* int a = 0; while (a &lt; 34)&#123; if (strcmp(key[a], word) == 0)&#123; b = 3; a++; break; &#125; else &#123; b = 1; a++; //否 &#125; &#125; if (b == 3)&#123; printf(&quot;(3,%s)\n&quot;, word); &#125;//~~~~~~~~~~~~~~~~~~~~~~~~ if (b == 1){ int q=0; for(int qq=0;strcmp(hh[qq],&quot;&quot;)!=0;qq++){ if(strcmp(word,hh[qq])==0){ q=1;break; } } if(q==1){ printf(&quot;(1,%d)\n&quot;,qq); q=0; }else{ for(qq=0;qq&lt;j;qq++){ hh[h][qq]=word[qq]; } printf(&quot;(1,%d)\n&quot;,h); h++; } /* int qq,yy=0; if(h==0){ for(qq=0;qq&lt;j;qq++){ hh[0][qq]=word[qq]; } printf(&quot;(1,%d)\n&quot;,h); h++; }else{ for(qq=0;qq&lt;h;qq++){ if(strcmp(hh[qq], word)==0){ yy=1; break; } } if(yy==0){ for(qq=0;qq&lt;j;qq++){ hh[h][qq]=word[qq]; } printf(&quot;(1,%d)\n&quot;,h); h++; yy=0; } else{ for(qq=0;qq&lt;h;qq++){ if(strcmp(hh[qq], word)==0) printf(&quot;(1,%d)\n&quot;,qq); yy=0; } } }*/ // } //1234567891011121314151617181920212223242526272829303132333435363738394041424344 &#125; else if (isDigit(Sourcecode[i]) == 1)//常数 &#123;int c = 0; while (isDigit(Sourcecode[i]))&#123; num[c] = Sourcecode[i]; i += 1; c++; &#125; printf(&quot;(2,%s)\n&quot;, num); &#125; else if (isDelimiter(Sourcecode[i]) == 1)&#123;//界符 printf(&quot;(5,%c)\n&quot;, Sourcecode[i]); i++; &#125; else if (isOperators(Sourcecode[i]) == 1)&#123;//运算符 if (Sourcecode[i] == &apos;:&apos; || Sourcecode[i] == &apos;&gt;&apos; || Sourcecode[i] == &apos;&lt;&apos;&amp;&amp;Sourcecode[i + 1] == &apos;=&apos;)&#123; printf(&quot;(4,%c%c)\n&quot;, Sourcecode[i], Sourcecode[i + 1]); i += 2; &#125; else&#123; printf(&quot;(4,%c)\n&quot;, Sourcecode[i]); i+= 1; &#125; &#125; else&#123; if(Sourcecode[i]!=&apos;\0&apos;) printf(&quot;(error,%c)\n&quot;,Sourcecode[i]); if(Sourcecode[i+1]!=&apos;\0&apos;)&#123; i+=1;&#125; else i=100; &#125; &#125; &#125; goto back;&#125; 编程感悟1.需要对是否为标识符、常数、保留字、运算符、界符进行判断，应用布尔类型完美的解决这个问题。 2.++i与i++都是i=i+1的含义，但是++i表示执行前i=i+1，而i++表示执行后i=i+1。 3.用一维数组来表示字符串，二维数组用来表示字符串的集合，并且用strcmp(string_1,string_2)来进行字符串内容的比较，相同返回0。 4.对于相同的标识符来说，入口应该相同，所以在对这里进行处理的时候，声明一个二维数组用来存放各个标识符（字符或者字符串），根据二维数组中的行下标进行入口标记。 5.好好学习一维数组、二维数组的应用场景以及应用原理。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行计算π值]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[并行计算π值 并行计算定义 并行计算或称平计算是相对于串行计算来说的。它是一种一次可执行多个指令的算法，目的是提高计算速度，及通过扩大问题求解规模，解决大型而复杂的计算问题。所谓并行计算可分为时间上的并行和空间上的并行。时间上的并行就是指流水线技术，而空间上的并行则是指用多个处理器并发的执行计算。 并行计算特征1、将工作分离成离散部分，有助于同时解决； 2、随时并及时地执行多个程序指令； 3、多计算资源下的解决问题的耗时要少于单个计算资源下的耗时。 网络设置并行计算机是靠网络将各个处理机或者处理器连接起来的，一般有以下几种方式，处理单元间有着固定连接的一类网络，在程序执行期间，这种点到点的链接保持不变。 命令配置IP地址1.点击菜单栏右侧的wifi图标，选择Edit Connections按钮。 2.点击Edit按钮编辑现有的有线连接。切换到IPV4 Settings选项卡，Method选择手动设置IP模式（Manual），点击add按钮添加IP。IP地址自行设定（如：192.168.0.1）保证4个节点在同一网段（网关相同）。子掩码255.255.255.0，网关根据IP设置（如：192.168.0.1），保存即设定成功。（可能需要手动点击wifi选择Ethernet Connection1） 安装ssh服务1234sudo dpkg -i libck*sudo dpkg -i openssh-client*sudo dpkg -i openssh-sftp*sudo dpkg -i openssh-server* 启动ssh服务1sudo service ssh start 安装MPICH2123456789cd//切换到家目录cp softWare/mpich2-1.0.6.tar.gz ./ //回车复制软件包到家目录tar zxf mpich2-1.0.6.tar.gz //回车解压目录mv mpich2-1.0.6 mpich2 //回车对文件夹进行重命名cd mpich2 //回车切换到软件根目录./configure //运行配置文件，运行后会输出很多的信息，请注意过程中是否有Error信息make //编译软件，运行后会输出很多的信息，请注意过程中是否有Error信息sudo make install //运行后会输出很多信息，请注意过程中是否有Error信息//到此MPICH2 安装完成 检测MPICH2是否安装成功123456which mpd//输出：/usr/local/bin/mpdwhich mpiexec//输出：/usr/local/bin/mpiexecwhich mpdboot//输出：/usr/local/bin/mpdboot 配置系统文件1.切换到集群机的第一个节点，打开终端。输入命令cd回车切换到家目录。 2.输入nano .mpd.conf//建立MPICH2的配置文件。并在窗口中输入MPD_SECRETWORD=123456,然后 ctrl+shift+o保存更改，回车，最后ctrl+x退出nano编辑器（注意.mpd.conf是隐藏文件，需要ls -al才能看 见，文件结尾不要换行） 3.输入chmod 600 .mpd.conf//修改文件权限 4.nano mpd.hosts//建立集群节点的列表文件，并在窗中输入参与节点的主机名，文件结尾不要换行。然 后保存关闭窗口。 5.输入命令 sudonano /etc/hosts 修改系统host文件 。将第二行的127.0.0.1修改为本机的IP地址。忘记IP 地址可以使用 ifconfig 命令查看。最后再把其他运算节点的IP 和 主机名加入到host 文件中。保存并退出 nano 编辑器。 6.输入命令 ping 主机名 检查是否能够与其他主机联通，如果不能联通 使用 ping IP地址 的方式检查。如果 不能ping 通主机名，检查是否正确修改 /etc/hosts 文件 ，如果不能ping 通 IP 检查节点是否正确连接有线网 络，或者IP地址是否正确。 7.输入命令 ssh-keygen 生成SSH密钥，过程中一路回车，不需要进行输入操作。 8.输入命令 cd .ssh 切换到ssh目录。通过ls 命令查看目录下面的文件，再输入命令 cp id_rsa.pub authorized_keys 复制公钥为认证密钥 ，通过 ls 命令显示目录下的文件。 9.输入命令 cd切换到家目录。 再输入命令 scp -r .sshgjy@011225-2:~/ 将ssh目录复制到其他节点。 （scp 为远程复制命令，该命令需要执行多次将ssh目录复制到每一个节点 用户名@**主机名），第一次复 制需要输入yes，然后输入密码。 10.输入命令 scp /etc/hosts .mpd.conf mpd.hosts gjy@011225-2:~/ 将3个文件复制到其他节点。（该 命令需要执行多次，此时已经不需要输入密码，如果还需要密码，则ssh免密码登陆没有生效，请检查步骤 6、7、8操作是否正确）。 11.输入命令 ssh 用户名@主机名（如 ssh gjy@011225-2） 登陆到其他节点。 12.输入命令 sudomv hosts /etc/替换本机etc目录下的hosts 文件。 13.输入命令 exit 退出远程登陆。重复 9 ~ 12 步，直到每个节点都有这3个文件。 做π的并行计算123mpdboot -n 4 -f mpd.hosts //启动并行运算节点。（4为所有运算节点数 ，不能超过mpd.host文件中定义的主机数）mpdtrace -l //查看所有启动的节点mpiexec -n 4 ./mpich2/examples/cpi //并行计算PI值（4为运算的进程数，可以任意定义） 运行其他程序1.编译文件 queen.c 1mpicc -o queen queen.c//编译完成将生成一个叫.queen的文件 2.拷贝可执行文件到其他节点 12scp queen gjy@011224-2:~/scp queen gjy@011224-2:~/ 3.并行计算 1mpiexec -n 4 ./queen]]></content>
      <categories>
        <category>并行计算</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>并行计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String类型的骚操作（2）]]></title>
    <url>%2F2018%2F03%2F19%2FJava%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java中String类型的骚操作（2） String类包含的获取子串的方法 方法 描述 substring(beginIndex) 返回该字符串的子串，从特定位置beginIndex的字符开始到字符串的结尾 substring(beginIndex,endIndex) 返回该字符串的子串，从特定位置beginIndex的字符开始到下标为endIndex-1的字符 1）使用substring(beginIndex)方法： 123String message = &quot;Welcome to Java&quot;;Strnig s1 = message.substring(11);System.out.println(s1);//返回Java 这里需要注意的是“W”其实是第0个字符，所以“J”是第11个字符。 2）使用substring(beginIndex,endIndex)方法： 123String message = &quot;Welcome to Java&quot;;String s1 = message.substring(0,10);System.out.println(s1);//返回Welcome to 获取字符串中的字符或者子串 方法 描述 indexOf(ch) 返回字符串中出现的第一个ch的下标，如果没有匹配的，返回-1 indexOf(ch,fromIndex) 返回字符串中的fromIndex之后出现的第一个ch的下标，如果没有匹配的，返回-1 indexOf(s) 返回字符串中出现的第一个字符串s的下标，如果没有匹配，返回-1 indexxOf(s,fromIndex) 返回字符串中fromIndex后出现的第一个字符串s的下标，如果没有匹配的，返回-1 lastIndexOf(ch) 返回字符串中出现的最后一个ch的下标，如果没有匹配，返回-1 lastIndexOf(ch,fromIndex) 返回字符串中fromIndex之前出现的最后一个ch的下标，如果没有匹配的，返回-1 lastIndexOf(s) 返回字符串中出现的最后一个字符串s的下标，如果没有匹配的，返回-1 lasIndexOf(s,fromIndex) 返回字符串忠fromIndex之前出现的最后一个ch的下标，如果没有匹配的，返回-1 1）使用indexOf(ch)方法和indexOf(ch,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.indexOf(&quot;W&quot;));//返回 0System.out.println(message.indexOf(&quot;0&quot;,5));//返回9 2）使用indexOf(s)方法和indexOf(s,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.indexOf(&quot;come&quot;));//返回3System.out.println(message.indexOf(&quot;Java&quot;,5));//返回11 3）使用lastIndexOf(ch)方法和lastIndexOf(ch,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.lastIndexOf(&quot;W&quot;));//返回0System.out.println(message.lastIndexOf(&quot;o&quot;,5));//返回4 4）使用lastIndexOf(s)方法和lastIndexOf(s,fromIndex)方法： 123String message = &quot;Welcome to Java&quot;;System.out.println(message.lastIndexOf(&quot;come&quot;));//返回3System.out.println(message.lastIndexOf(&quot;Java&quot;,5));//返回-1 PS:写的时候indexOf(“w”)和indexOf(‘w’)是一样的，用””和’’都行。 ​ 字符串的骚操作就告一段落了。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String类型的骚操作（1）]]></title>
    <url>%2F2018%2F03%2F18%2FJava%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Java中String类型的骚操作 String对象的简单实用方法 方法 描述 length() 返回字符串中的字符数 charAt(index) 返回字符串中指定位置的字符 concat（s1） 将本字符串和字符串s1相连，返回一个新的字符串 toUpperCase() 返回一个新的字符串，只有大写字母 toLowerCase() 返回一个新的字符串，只有小写字母 trim() 返回一个新的字符串，去掉了两边的空白字符 1)使用length()方法获取长度： 12String message = &quot;Welcome to Java&quot;；System.out.println(&quot;The length of &quot;+message+&quot;is&quot;+message.length()); 显示： 1The length of Welcome to Java is 15 2)使用charAt(index)方法获取字符： 12String message = &quot;Welcome to Java&quot;；System.out.println(message.charAt(0)); 显示： 1W 3）使用concat(s2)连接字符串： 1234String s1 = &quot;Welcome to&quot;;String s2 = &quot;Java&quot;;Strnig s3=s1.concat(s2);System.out.println(s3); 显示： 1Welcome to Java 4)使用toUpperCase()、toLowerCase()实现字符串的转换： 12345String message = &quot;Welcome to Java&quot;;String s2 = message.toUpperCase(message);String s3 = message.toLowerCase(message);System.out.println(s2);System.out.println(s3); 显示： 12WELCOME TO JAVAwelcome to java String 对象的比较方法 方法 描述 equals(s1) 如果该字符串等于字符串s1，返回true equalsIgnoreCase(s1) 如果该字符串等于字符串s1，返回true，不区分大小写 compareTo(s1) 返回一个大于0、等于0、小于0的整数，表明字符串是否大于、等于、小于s1 compareToIgnoreCase(s1) 和compareTo(s1)一样，除了不区分大小写之外 startsWith(prefix) 如果字符串以特定的前缀开始，返回true endsWith(suffix) 如果字符串以特定的后缀结束，返回true contains(s1) 如果s1是该字符串的子字符串，返回true 1）使用“==”只能检测字符串是否指向同一个对象，而equals方法可以判断两个字符串内容是否相同。 12345String s1 = &quot;Welcome to Java&quot;;String s2 = &quot;Welcome to java&quot;;String s3 = &quot;Welcome to maliao&quot;;System.out.println(s1.equals(s2));//return trueSystem.out.println(s1.equals(s3));//return false 2）compareTo方法也可以比较字符串，按照字典顺序（Unicode码的顺序）进行比较。 123String s1 = &quot;abc&quot;;String s2 = &quot;abg&quot;;System.out.println(s1.compareTo(s2));//返回-4 3）startsWith(prefix)、endsWith(suffix)的使用方法： 12345String s1 = &quot;Welcome to Java&quot;;System.out.printn(s1.startsWith(&quot;We&quot;));//return trueSystem.out.println(s1.startsWith(&quot;we&quot;));//return falseSystem.out.println(s1.endsWith(&quot;va&quot;);//retrun trueSystem.out.println(s1.endsWith(&quot;Va&quot;));//return false String的更多骚操作请见下一条博客。]]></content>
      <categories>
        <category>Java(基础篇)</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非凡匠心]]></title>
    <url>%2F2018%2F03%2F14%2F%E9%9D%9E%E5%87%A1%E5%8C%A0%E5%BF%83%2F</url>
    <content type="text"><![CDATA[非凡匠心 节目介绍 今天给大家推荐一档节目，名字叫做《非凡匠心》，由张国立带队并且每一期带一个新嘉宾，去寻求国宝级非物质文化遗产代表人，并向他们学习中国传统文化。每一期嘉宾都有他们自己的特点，有的是综艺大咖，有的是歌手、演员等等。当然，每期张国立老师必在（第二季第二期不在，原因自寻），张国立老师可以说是非常适合这个节目了，当然不是说其他人不合适，而是张国立老师积累了大半辈子演艺经验以及生活经验，不论学习什么，都不会显得束手无策、无从下手。又不论与什么人交流，都游刃有余并且还会一些地方方言，能够迅速拉近人与人之间的距离。可以说，节目组选择张国立老师是一个明智的原则。 推荐原因 本人是从第二期开始看的，目前一共播出五期，第一期“张国立携任贤齐勇闯龙泉求宝剑”，第二期“海清独自挑战造纸工艺”，第三期“张国立高晓菲师兄妹直面“窑死窑生””，第四期“张国立杨迪同赴山西求学制药秘诀”，第五期“张国立李玉刚演绎皮影戏版“贵妃醉酒””。而正是因为最近更新的这一期“皮影戏”让我更加有了推荐大家去看的想法（之前看第一期的时候就有推荐）。 第五期中，张国立老师和李玉刚来到了陕西华县高塘镇魏家塬村，这里是五人忙（华县）皮影戏的发源地。首先来到的是魏金全家，并在这里取景落镜。这次的五个人分别是：前声（吕崇德）、签手（魏金全）、上档（刘东耀）、下档（刘华）、后台（魏亚民）。其中最有特点两位便是吕崇德和刘华。吕崇德老师坚守传统，不希望破坏皮影戏特有的”碗碗腔“，不想让皮影戏变得“土不土，洋不洋“。而刘华老师认为不能老停留在这个原汁原味上，应该整个社会与时俱进。弹幕有人说评论说”刘华老师思想前卫“，”吕崇德老师腐朽顽固“。其实，两位老师何尝不想既保持原汁原味又能传承下去，只是时代不一样了，必须要做出这个鱼和熊掌不可兼得的选择。两位老爷子我都很喜欢，可能因为吕崇德老爷子是前声的原因，当他唱出来的时候，每每都感觉震撼心酸。震撼是中华传统文化的博大精深，心酸的是只剩下这么几个老爷子还在坚持着，或许真的像他们自己说的那样：“也就剩十来年了吧”。当李玉刚找到他们并告明来意后，看得出每个人对能够再次登台演出，十分欣喜，甚至迫不及待并且在演出时穿上了最隆重的衣服，或许皮影戏就是他们的全部。在表演准备阶段，每个人都认真地准备着，像整理着装准备奔赴战场的士兵。演出过程中，张国立老师突然忘词，全场一片安静，正在这个时候，吕崇德老师立马接上张国立老师的台词，保证了演出的继续。镜头转向他的时候，吕崇德老师，面无表情，可以看得出内心的平静，这可能就是一种境界吧。也或许是像弹幕抖得机灵一样：“你这样的学生我见得多了”。如果学生真的多，那该多好。与其说他们是华县皮影戏的老戏骨、老艺术家，不如称他们为华县皮影戏的精神，无形无味，却让人望而生畏。 感悟 有些记忆，很轻很轻，像在梦里回到过去。有些牵挂，很重很重，想要离开就是一生的悲欣。对皮影大师而言，光影是多么神秘的游戏。灯光一亮，碗碗腔一起，一夫当关的骁勇酣畅。美景良辰的赏心乐事，都是往昔，散落在时光里的珍宝。更是梦境的永续留存。 希望像华县皮影戏这样的非物质文化遗产能够很好的传承下去，不要在我们这一代丢失。也希望这些老艺术家们能够健健康康、长命百岁。为你们深深的鞠一躬！ 文字非常稚嫩，希望各位观众老爷包容。]]></content>
      <categories>
        <category>生活小调</category>
      </categories>
      <tags>
        <tag>节目推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓简易计算器]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%AE%89%E5%8D%93%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[安卓简易计算器 安卓 Android是由Andy Rubin创立的一个手机操作系统，后来被Google收购。Gooole希望与各方面共同建立一个标准化的、开放式的移动电话软件平台，从而在移动产业形成一个开放式的操作平台。 界面编程 安卓常用的几种布局：线性布局（LineraLayout）、表格布局（Tablelayout）、帧布局（FrameLayout）、相对布局（RelativeLayout）等等。我这里用的是比较简单的“线性布局”。 布局文件（activity_main.xml）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.example.zhaoxudong.calculatorapp.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; tools:layout_editor_absoluteY=&quot;0dp&quot; tools:layout_editor_absoluteX=&quot;0dp&quot;&gt; &lt;EditText android:layout_width=&quot;403dp&quot; android:layout_height=&quot;155dp&quot; android:id=&quot;@+id/result_Text&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;CE&quot; android:id=&quot;@+id/CE&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;DEL&quot; android:id=&quot;@+id/DEL&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;SIN&quot; android:id=&quot;@+id/SIN&quot;/&gt; &lt;Button android:layout_width=&quot;113dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;COS&quot; android:id=&quot;@+id/COS&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;7&quot; android:id=&quot;@+id/number7&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;8&quot; android:id=&quot;@+id/number8&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;9&quot; android:id=&quot;@+id/number9&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;117dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;+&quot; android:id=&quot;@+id/add_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;4&quot; android:id=&quot;@+id/number4&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;5&quot; android:id=&quot;@+id/number5&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;6&quot; android:id=&quot;@+id/number6&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;117dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;-&quot; android:id=&quot;@+id/sub_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;1&quot; android:id=&quot;@+id/number1&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;2&quot; android:id=&quot;@+id/number2&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;3&quot; android:id=&quot;@+id/number3&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;116dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;*&quot; android:id=&quot;@+id/mult_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;=&quot; android:id=&quot;@+id/sign_but&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;0&quot; android:id=&quot;@+id/number0&quot;/&gt;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;.&quot; android:id=&quot;@+id/spot_but&quot;/&gt; &lt;Button android:layout_width=&quot;114dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;/&quot; android:id=&quot;@+id/div_but&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 界面效果： 逻辑部分 逻辑部分是由java代码实现，实践证明代码多练还是有好处的。 为了实现按钮的点击事件： 1public class MainActivity extends Activity implements OnClikListener&#123;&#125; 对layout中的按钮进行定义： 1234567891011121314151617181920212223242526272829303132333435private Button number0;private Button number1;private Button number2;private Button number3;private Button number4;private Button number5;private Button number6;private Button number7;private Button number8;private Button number9;/*运算符 */private Button add_but;//加法private Button sub_but;//减法private Button mult_but;//乘法private Button div_but;//除法/*等号小数点归零 */private Button sign_but;//等号private Button spot_but;//小数点private Button CE_but;//归零键private Button DEL;private Button SIN;private Button COS;/*结果 */private EditText result;private boolean clear_flag;//清空标识 对每个按钮进行实例化并且设置点击事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /* 数字 */ number0 = (Button) findViewById(R.id.number0); number1 = (Button) findViewById(R.id.number1); number2 = (Button) findViewById(R.id.number2); number3 = (Button) findViewById(R.id.number3); number4 = (Button) findViewById(R.id.number4); number5 = (Button) findViewById(R.id.number5); number6 = (Button) findViewById(R.id.number6); number7 = (Button) findViewById(R.id.number7); number8 = (Button) findViewById(R.id.number8); number9 = (Button) findViewById(R.id.number9); /* 运算符 */ add_but = (Button) findViewById(R.id.add_but); sub_but = (Button) findViewById(R.id.sub_but); mult_but = (Button) findViewById(R.id.mult_but); div_but = (Button) findViewById(R.id.div_but); /* 等号 小数点 归零 */ sign_but = (Button) findViewById(R.id.sign_but);//等号 spot_but = (Button) findViewById(R.id.spot_but);//小数点 CE_but = (Button) findViewById(R.id.CE);//归零 DEL = (Button) findViewById(R.id.DEL); SIN=(Button) findViewById(R.id.SIN); COS=(Button) findViewById(R.id.COS); /* 结果 */ result = (EditText) findViewById(R.id.result_Text); /* 初始化事件 */ number0.setOnClickListener(this); number1.setOnClickListener(this); number2.setOnClickListener(this); number3.setOnClickListener(this); number4.setOnClickListener(this); number5.setOnClickListener(this); number6.setOnClickListener(this); number7.setOnClickListener(this); number8.setOnClickListener(this); number9.setOnClickListener(this); add_but.setOnClickListener(this); sub_but.setOnClickListener(this); mult_but.setOnClickListener(this); div_but.setOnClickListener(this); sign_but.setOnClickListener(this); spot_but.setOnClickListener(this); CE_but.setOnClickListener(this); DEL.setOnClickListener(this); SIN.setOnClickListener(this); COS.setOnClickListener(this); &#125; 下面是在onClick方法中实现逻辑运算： 这里使用的方法是使用以下代码获取EditText中的字符串 1String str = result.getText().toString(); 为了区分开数字和运算符，分别用s1、s2和op来表示数字和运算符 123String s1 = exp.substring(0, exp.indexOf(&quot; &quot;));//运算符前面的字符串String op = exp.substring(exp.indexOf(&quot; &quot;) + 1, exp.indexOf(&quot; &quot;) + 2);//截取到的运算符String s2 = exp.substring(exp.indexOf(&quot; &quot;) + 3);//运算符后面的字符串 为了能够实现点击任意按钮可以出现对应的字符，使用以下代码可以获取Button中的内容 1result.setText(str + &quot; &quot; + ((Button) v).getText() + &quot; &quot;); 通过判断出数字和运算符来进行运算，下面是逻辑运算全部的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void getResult() &#123; clear_flag = true; String exp = result.getText().toString(); double result_1 = 0; if(exp==null||exp.equals(&quot;&quot;))&#123; return; &#125; if(!exp.contains(&quot; &quot;))&#123; return; &#125; if (clear_flag)&#123; clear_flag=false; &#125; clear_flag=true; String s1 = exp.substring(0, exp.indexOf(&quot; &quot;));//运算符前面的字符串 String op = exp.substring(exp.indexOf(&quot; &quot;) + 1, exp.indexOf(&quot; &quot;) + 2);//截取到的运算符 String s2 = exp.substring(exp.indexOf(&quot; &quot;) + 3);//运算符后面的字符串 if (!s1.equals(&quot;&quot;) &amp;&amp; !s2.equals(&quot;&quot;)) &#123; double d1 = Double.parseDouble(s1); double d2 = Double.parseDouble(s2); if (op.equals(&quot;+&quot;)) &#123; result_1 = d1 + d2; &#125; else if (op.equals(&quot;-&quot;)) &#123; result_1 = d1 - d2; &#125; else if (op.equals(&quot;*&quot;)) &#123; result_1 = d1 * d2; &#125; else if (op.equals(&quot;/&quot;)) &#123; if (d2 == 0) result_1 = 0; result_1 = d1 / d2; &#125; if (!s1.contains(&quot;.&quot;) &amp;&amp; !s2.contains(&quot;.&quot;)&amp;&amp;!op.equals(&quot;/&quot;)) &#123; int r = (int) result_1; result.setText(r + &quot;&quot;); &#125; else &#123; result.setText(result_1 + &quot;&quot;); &#125; &#125; else if (!s1.equals(&quot;&quot;) &amp;&amp; s2.equals(&quot;&quot;)) &#123; result.setText(exp); &#125; else if (s1.equals(&quot;&quot;) &amp;&amp; !s2.equals(&quot;&quot;)) &#123; double d2 = Double.parseDouble(s2); if (op.equals(&quot;+&quot;)) &#123; result_1 = 0 + d2; &#125; else if (op.equals(&quot;-&quot;)) &#123; result_1 = 0 - d2; &#125; else if (op.equals(&quot;*&quot;)) &#123; result_1 = 0; &#125; else if (op.equals(&quot;/&quot;)) &#123; result_1 = 0; &#125; &#125; else &#123; result.setText(&quot;&quot;); &#125; &#125; 以上便是简单计算器的所有重要代码。 实现功能 支持加减乘除的基本运算 支持加减乘除后的再运算 支持浮点数运算 支持三角函数sin cos运算 支持数字删除 支持置零 随便聊聊第一次写博客，算是大学将尽一个学渣的挣扎，总是要还的，大一不努力，那就现在来补充吧。用hexo和github实现这个博客的搭建还用了差不多一天时间，感谢我河北老乡（名字被马赛克了）的帮助。希望自己能够一直保持热情，加油！]]></content>
      <categories>
        <category>Android编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux SHELL脚本设计]]></title>
    <url>%2F2017%2F12%2F19%2FLinux%20SHELL%E8%84%9A%E6%9C%AC%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Linux SHELL脚本设计 SHELL程序的主要用途 在SHELL程序中不仅仅可以使用命令的集合，而且可而且可以安排自动化处理过程，因此可以通过编写SHELL程序使大量的任务执行实现自动化。SHELL比较擅长完成系统管理任务，尤其适合完成那些易用性、可维护性和便携性比执行效率更优先的任务。 SHELL程序的执行和调试⑴在bash的SHELL程序设计中，程序必须以下面的行开始： ​ #！/bin/bash 这里符号#！用来告诉系统，后面给出的参数是用来执行该文件的程序。 ⑵当编辑完一个SHELL脚本后，要使该脚本能够执行，还必须使该脚本文件具有可执行权。需要执行命令：chmod +x filename ⑶在shell程序中，以#开头到一个行结束的句子表示注释信息。建议大家在编写shell程序时养成添加注释的习惯，因为注释不仅能给其他需要熟悉悉该程序的人以帮助，也能给出脚本编写者设计原理的提示。 ⑷进行shell程序设计时，必定会用到变量。Shell编程中使用的变量有自己的特色，即所有的变量都是由字符串组成的，而且对变量无须进行声明，可直接进行变量赋值操作。 程序设计1.创建以下菜单程序USER:** HOST: ** DATE: xx/xx/20xx A: 创建子目录并复制文件 B: 文件权限测试 C: 文件字符转换 D: 文件总数及文本行数统计 E: 文件查找 Q: 退出系统 ——————————————————————————————— A：在用户家目录下创建名字为本人姓名的子目录，其存取权限为(drwxr-xr-x)。测试目录确实存在后，将已存在的file1、file2两文件拷入其中并分别显示两文件的内容。显示完成后将file1、file2两文件截断为大小为0的空文件。 B：测试当前用户对系统中某文件是否有r、w、x的权限，输出测试结果。 C：将file1、file2两文件中的小写字符转换为大写，并将转换后的内容分别写入新文件。判断上述操作成功后分别显示转换后的新文件的内容。 D：统计/dev目录下目录文件和符号链接文件的数目；统计系统中某文本文件中空行的行数；显示当前系统中所有环境变量。 E：在/dev目录下查找由s开头且文件名由5个字符组成的文件，找到后用file命令显示其文件类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/bin/bashUSER= &apos;whoami&apos;HOST=`hostname -s`MYDATE=`date +%d/%m/%y`while :doclearcat &lt;&lt; MAYDAY----------------------------------------------------------------- User:$USER Host:$HOST Date:$MYDATE----------------------------------------------------------------- A:创建子目录并复制文件 B:文件权限测试 C:文件字符转换 D:文件总数及文本行数统计 E:文件查找 Q:退出系统------------------------------------------------------------------MAYDAYecho -n &quot;Please Choose [A,B,C,D,E,Q]&gt;&quot;read CHOICEcase $CHOICE inA)echo &quot;A:创建子目录并复制文件&quot;echo &quot;输入要创建的文件名:&quot;read FILEmkdir $FILEchmod 755 $FILEtest -d $FILEif [ $? -eq 0 ]thencp file1 $FILEcp file2 $FILEecho &quot;file1 内容&quot;cat file1:&gt;$FILE/file1echo &quot;file2 内容&quot;cat file2:&gt;$FILE/file2fi;;B)echo &quot;B:文件权限测试&quot;echo &quot;请输入要测试的文件绝对路径&quot;read NAME1test -r $NAME1if [ $? -eq 0 ]thenecho &quot;可读&quot;elseecho &quot;不可读&quot;fitest -w $NAME1if [ $? -eq 0 ]thenecho &quot;可写&quot;elseecho &quot;不可写&quot;fitest -x $NAME1if [ $? -eq 0 ]thenecho &quot;可执行&quot;elseecho &quot;不可执行&quot;fi;;C)echo &quot;C:文件字符转换&quot;cat file1 | tr &quot;[a-z]&quot; &quot;[A-Z]&quot; &gt;file1.trdiff -q file1 file1.trif [ $? -eq 1 ]thenecho &quot;file1.tr 内容&quot;cat file1.trficat file2 | tr &quot;[a-z]&quot; &quot;[A-Z]&quot; &gt;file2.trdiff -q file2 file2.trif [ $? -eq 1 ]thenecho &quot;file2.tr 内容&quot;cat file2.trfi;;D)echo &quot;/dev 目录下目录文件和符号链接文件的数目&quot;find /dev -type d | wc -lfind /dev -type l | wc -lecho &quot;file1 空行行数统计&quot;grep ^$ file1 | wc -lecho &quot;显示当前系统中所有环境变量&quot;env;;E)echo &quot;文件查找&quot;find /dev -name &apos;s????&apos; | xargs file;;Q)exit 0;;*)echo &quot;输入不符合条件！请回车后输入[A.B.C.D.E.Q]&quot;esacread DDdone 2.文件pc.txt中保存了三个班级的学生选课成绩试编写一段shell程序对文件内容进行统计、计算后输出各个班级选课的学生人数及每班选课成绩的优秀率。 pc.txt 文件内容 如下： Student1: 1301: 75 Student2: 1302: 96 Student3: 1303: 99 Student4: 1302: 93 Student5: 1303: 23 Student6: 1301: 77 1234567891011121314151617#!/bin/bashtotal1=`grep -F 1301 pc.txt|wc -l`gradeA1=`grep -F 1301 pc.txt|awk -F： &apos;$3 &gt; 90&apos;|wc -l`rateA1=$(($gradeA1*100/$total1))total2=`grep -F 1302 pc.txt|wc -l`gradeA2=`grep -F 1302 pc.txt|awk -F： &apos;$3 &gt; 90&apos;|wc -l`rateA2=$(($gradeA2*100/$total2))total3=`grep -F 1303 pc.txt|wc -l`gradeA3=`grep -F 1303 pc.txt|awk -F： &apos;$3 &gt; 90&apos;|wc -l`rateA3=$(($gradeA3*100/$total3))echo &quot;各班选课人数及优秀率（90及以上为优秀）&quot;echo &quot;1301班选课人数为$total1,优秀率为$rateA1%&quot;echo &quot;1302班选课人数为$total2,优秀率为$rateA2%&quot;echo &quot;1303班选课人数为$total3,优秀率为$rateA3%&quot; 3.学习、理解find和grep(家族)命令编制两个个性化的文件搜索工具。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/bin/bashecho &quot;个性化文件搜索工具:&quot;echo &quot;1:grep搜索工具&quot;echo &quot;2:find搜索工具&quot;echo &quot;选择想要使用的工具[1|2]:&quot;read CHOICEif [ &quot;$CHOICE&quot; == &quot;1&quot; ] #选择grepthenecho &quot;自定义查找&quot;echo &quot;请输入查找目录:&quot;read mululs $mulu &gt; mulu.txtecho &quot;1:查找以匹配模式开头的文件&quot;echo &quot;2:查找不包含匹配模式的文件&quot;echo &quot;3:查找以匹配模式结尾并且长度固定的文件&quot;read CHOICE1case $CHOICE1 in 1)echo &quot;查找以匹配模式开头的文件&quot; read scanf grep -E ^$scanf mulu.txt;; 2)echo &quot;查找不包含匹配模式的文件&quot; read scanf grep -Ev $scanf mulu.txt;; 3)echo &quot;查找以匹配模式结尾并且长度固定的文件&quot; read scanf echo &quot;请输入长度&quot; read length readlength=$(($length-`echo $&#123;#scanf&#125;`)) grep -xE [[:alnum:]]\&#123;$readlength\&#125;$scanf mulu.txt;; *)esacelse #选择findecho &quot;自定义查找&quot;echo &quot;请输入查找目录:&quot;read mulu2echo &quot;1:查找文件大小大于给定下限的文件&quot;echo &quot;2:查找给定时间内修改过的文件&quot;echo &quot;3:查找给定文件后缀的文件&quot;read CHOICE2case $CHOICE2 in 1)echo &quot;请输入文件大小下限值(k)&quot; read size find $mulu2 -size +$size ;; 2)echo &quot;请输入时间(day)&quot; read time find $mulu2 -mtime +$time ;; 3)echo &quot;请输入文件后缀&quot; read houzhui find $mulu2 -name *.$houzhui;; *)esacfiread DD]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下目录及其操作命令]]></title>
    <url>%2F2017%2F12%2F17%2FLinux%E4%B8%8B%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux下目录及其操作命令 创建和删除目录的命令mkdir命令用来创建目录。 -m, –more=MORE 将新建目录的存取权限设置为MORE,存取权限用给定的八进制数字表示。 -p, –panrents 可一次性建立多个目录，即如果新建目录所指定的路径中有些父目录尚不存在，此选项可以自动建立他们。 12$ mkdir --more=700 /home/mengqc/test (在目录/home/mengqc下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问)$ mkdir -p -m 750 bin/os_1 (在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写执行，用户组可读和执行，其他用户无权访问) rmdir命令从一个目录中删除一个或多个空的子目录。 -p –parents 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果有非空目录，则该目录保留下来。 12$ cd /home/mengqc/testrmdir -p bin/os_1 (删除子目录os_1和其父目录bin) 改变工作目录和显示目录内容的命令cd命令改变工作目录。 123$ cd /home/liu (将当前目录改到/home/liu)$ cd (将当前目录改到用户的主目录)$ cd ../.. (将当前目录向上移动两级) pwd命令显示当前工作目录的绝对路径。 12$ pwd/home/mengqc ls命令列出指定目录的内容。 -a, –all 显示指定目录下所有子目录和文件，包括”.”开头的隐藏文件（例如.cshrc）。 -A, –almost-all 显示指定目录下所有子目录和文件，包括”.”开头的隐藏文件，但是列出”.”和”..”目录项 -b, –escape 当文件名中包含不可显示的字符时，则用\ddd（3位八进制数）形式显示该字符。 -c 按文件的修改时间排序 -C 分成多列显示项目 -d 如果参数是目录，则只显示它的名字，往往与-l选项一起用，以得到目录的详细信息。 -i, –inode 在输出的第一行显示文件的I节点号。 1234$ ls -F (列出当前目录的内容，并标出文件的属性)Desktop/ ex1 ex2 m1.c m2.c test/$ ls -C /home/mengqc (按多列形式列出目录/home/mengqc的内容)$ ls -lai (以长列表格式列出当前目录的内容，包含隐藏文件和他们的I节点号) 链接文件的命令硬链接建立硬链接时，在别的目录或者本目录中增加目标文件的一个目录项，这样一个文件就登记在多个目录中。创建硬链接后，已经存在的文件的I节点号（Inode）会被多个目录文件项使用。 对硬链接有如下限制： ①不能对目录文件创建硬链接。 ②不能在不同的文件系统之间创建硬链接。就是说链接文件和被链接文件必须位于同一个文件系统中。 符号链接符号链接也称为软链接，是将一个路径名链接到另一个文件。这些文件是一种特别类型的文件。事实上，他只是一个文本文件，其中包含了它提供链接的另一个文件的路径名，另一个文件是实际包含所有数据的文件。所有读写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。 ln命令用来创建链接。 -s, –symbolic 建立符号链接，而不是硬链接。 123$ cd /home/mengqc$ ln mub1/m2.c /home/liu/a2.c (将目录/home/mengqc/mub1下的文件m2.c链接到目录/home/liu下的文件a2.c)$ ln -s /home/mengqc/mub1 /home/liu/abc (在目录/home/liu下建立一个符号链接文件abc，使他指向目录/home/mengqc/mub1) 改变文件或目录存取权限的命令用户权限（1）文件主 Linux为每个文件都分配一个文件所有者，成为文件主，并赋予文件主唯一的注册名。对文件的控制取决于文件主或超级用户（root） 文件或目录的创建者对创建的文件或目录拥有特别使用权。 文件的所有关系是可以改变的，可以将文件或目录的所有权转让给其他用户，但只有文件主或者超级用户才有权改变文件的所有关系。文件所有权的标志是用户ID(UID). （2）用户组 当系统给管理员为用户建立账号后，会分配一个组ID合一个特定的用户组名。 （3）存取权限 Linux系统中的每个文件和目录都有存取许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 Linux系统规定了4中不同类型的用户：①文件主（owner）②同组用户（group）③可以访问系统的其他用户（others）④超级用户（root） 存取权限规定了3中访问文件或者目录的方式：①读（r）②写（w）③可执行或查询（x）。 chmod命令用于改变或者设置文件或目录的存取权限。 一般格式：chmod key 文件名 key：who 操作符号 mode [who]: u 用户（user），即文件或目录的所有者 g 同组（group）用户，即与文件属主有相同组ID的所有用户 o 其他（others）用户， a 所有（all）用户。他是系统默认值 [操作符号]: +添加某个权限 -取消某个权限 =赋予给定权限并取消原有权限 [mode]: r 可读 w 可写 x 可执行 123$ chmod a+x ex1 (将文件ex1的权限改为所有用户都有执行权限)$ chmod u=r ug=x ex1 （将ex1的权限诚信设置成文件主可以读和执行，组用户可以执行，其他用户无权限）$ chmod 0664 ex1 (使文件ex1的文件主和同组用户具有读、写权限，而其他用户只可读) umask命令用来设置限制新建文件权限的掩码。 1$ umask u=,g=w,o=rwxg (将组用户的写权限、其他用户的读/写和执行权限都取消) 改变用户组和文件主的命令chgrp命令改变文件或目录的所属的用户组。 -R，–recursive 递归式改变指定目录及其下面的所有子目录和文件的用户组。 1$ chgrp -R mengxin /home/mengqc (将/home/mengqc及其子目录下的所有文件的用户组改为mengxin) chown命令改变某个文件或目录的所有者和所属的组。 -R，–recursive 递归式改变指定目录及其下面的所有子目录和文件的文件主。 -v –verbose 详细列出该命令所做的工作。 ps：只有文件主和超级用户可以使用该命令。 1$ chown -R liu /home/mengqc (将目录/home/mengqc及下面的所有文件、子目录的文件主改为liu)]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下文件操作命令]]></title>
    <url>%2F2017%2F12%2F15%2FLinux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux下文件操作命令 文件显示命令cat命令链接文件并打印到标准输出设备上，cat经常用来显示文件的内容。 123$ cat m1 (在屏幕上显示文件m1的内容)$ cat m1 m2 (同时显示文件m1和m2的内容)$ cat m1 m2&gt;mfile (将m1和m2合并后放入文件mfile中) more命令显示文件内容，每次显示一屏。 -num 显示多少行 -c或者-p 显示前清屏 -s 将文件中空白行压缩成一个空白行显示 +num 从行号num开始 12$ more -dc mfile //显示文件内容，显示前先清屏，并在屏幕下方显示完整的百分比$ more -c -10 mfile //显示mfile文件的内容，每10行显示一次，显示前清屏 head命令在屏幕上显示指定文件的开头若干行。 123$ head -5 mfile (显示mfile前5行)$ head -v mfile (显示文件mfile的内容，并且给出文件名标题)$ head -q mfile (显示文件mifile的内容，但不列出文件名标题) tail命令在屏幕上显示指定文件的末尾若干行。 123$ tail mfile (显示文件mfile的最后10行)$ tail +20 mfile (显示文件mfile的内容，从第二十行至文件末尾)$ tail -c 10 mfile (显示文件mfile的最后10个字符) 匹配、排序及显示指定内容的命令grep命令1234$ grep -F mengqc /etc/passwd (在密码文件/etc/passwd中查找包含mengqc的所有行)$ grep -r &apos;print&apos; mengqc (在mengqc目录下和子目录下的所有文件中查找字符串print出现的次数)$ grep -E &apos;[Mm]ain|[Pp]rintf&apos; f1 f2 (在文件f1和f2中查找包含main或printf的所有行，不区分首字母大小写)$ grep -i &apos;main|printf&apos; (同上) sort命令对文本文件的各行进行排序。 1$ sort more_h10 (对more_h10文件排序) uniq命令从排好序的文件中去除重复行。 123$ uniq -u ex3 (显示文件ex3中不重复的行)$ uniq -d ex3 (只显示文件ex3中重复的行)$ uniq -c ex3 (显示输出时，在每行的首位加上该行在文件中出现的次数) 比较文件内容的命令comm命令对两个已经排序文件进行逐行比较。 1$ comm -12 m1 m2 （比较m1和m2，并且只显示他们共有的行） diff命令比较两个文本文件，并找出他们的不同，而且不用预先排序。 -b 忽略空格造成的差别。 比如”How are you”和”How are you”被看做相同字符。 -i 忽略字母大小的区别。 -r 当文件1和文件2都是目录的时候，递归比较找到各自的子目录。 复制、删除和移动文件的命令cp命令将源文件或者目录复制到目标文件或目录中。 123$ cp mfile /home/mengqc/exam1 (复制到/home/mengqc目录下，并改名为exam1)$ cp -r /home/mengqc /home/liuzh (将目录/home/mengqc下的所有文件以及子目录复制到/home/liuzh目录中)$ cp -i /home/mengqc/m*.c .home/liuzh (将目录/home/mengqc下的所有.c文件复制到/home/liuzh目录中) rm命令删除文件和目录。 1234$ rm -i test example (交互式删除当前目录下的文件test和example)rm：是否删除一般文件‘test’？n (不删除)rm: 是否删除一般文件‘example’？y （删除）$ rm -r * (删除目录下除隐含文件外的所有文件和子目录) mv命令对文件或目录重新命名，或者将文件从一个目录转移到另一个目录。 12$ mv ex3 new1 (将文件ex3改名为new1)$ mv /home/mengqc/* . (将目录/home/mengqc中的所有文件移到当前目录（用“.”表示）) 文件内容统计命令wc命令统计指定文件的字节数、字数、行数，并将统计结果显示出来。 -c, –bytes 统计字节数 -l, –line 统计行数 -w, –words 统计字数 12$ wc -lcw ex1 ex2 (统计文件ex1和文件ex2的字节数、字数和行数)$ wc ex1 ex2 (不带选项，统计文件ex1和ex2的字节数、字数和行数) 上面两种情况，执行结果一样。]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2017%2F12%2F13%2F%E5%8D%9A%E5%AE%A2%E6%96%BD%E5%B7%A5%E7%BB%93%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[博客施工结束 博客创建创建过程1.安装Node.js并配置好Node.js环境，通过cmd输入“node -v”和“npm -v”可验证。 12345C:\User\马里奥&gt;node -vv6.11.4C:\User\马里奥&gt;npm -v5.4.2 2.安装Git并配置好Git环境，安装成功的后，在电脑任何位置，鼠标右键出现“Git GUI Here”和“Git Bash Here”即成功。 3.注册Github并且新建一个仓库，仓库名称严格按照“账户名.github.io”来设置，同时勾选Initialize this repository with a README。 4.接下来便是安装hexo，提一嘴路径的问题，包括以上的所有安装都是自定义路径，然后在cmd中通过cd命令进入要安装的文件夹，使用“npm install hexo -g“命令进行安装，这时候静静的等待就好了。 1D:\blog&gt;npm install hexo -g 可以使用”hexo -v”命令检查是否安装成功，出现一大堆类似于版本号的东西就成功了。 1D:\blog&gt;hexo -v 5.同样是在这个文件夹的路径下，cmd中使用“hexo init”命令进行文件夹的初始化，也是需要静静等待的。当出现“Start blogging with Hexo”的时候，这一阶段就告一段落了。 1D:\blog&gt;hexo init 6.同样是在这个文件夹的路径下，cmd中使用“npm install”安装所需的组件。 1D:\blog&gt;npm install 7.组件安装成功后，这时候可以首次体验一下Hexo了，输入“hexo g”。然后在输入“hexo s”开启服务器，访问网址。 123D:\blog&gt;hexo gD:\blog&gt;hexo s 8.终于快要完成了，现在便是将Hexo和 Github page联系起来，使用Git bash设置Git的user name和email（在我设置的blog路径下，可以直接在这个文件夹里面鼠标右键选择Git Bash Here）。 1$ git config --global user.name &quot;maliao&quot; 1$ git config --global user.email &quot;xxxx@xx.com&quot; 9.选择C:\Users\Administrator.ssh路径下鼠标右键选择Git Bash Here，输入“ssh-keygen -t rsa -C “xxxx@xx.com“”,连续三个回车以后，生成秘钥，得到两个文件：id_rsa和id_rsa.pub。输入“eval “$(ssh-agent -s)””,添加密钥到ssh-agent，再输入ssh-add ~/.ssh/id_rsa，添加生成的SH key到ssh-agent 1$ sh-keygen -t rsa -C &quot;xxxx@xx.com 1$ eval &quot;$(ssh-agent -s)&quot; 1$ ssh-add ~/.ssh/id_rsa 10.登录Github，点击个人头像里的settings添加ssh。点击左边的SSH and GPG keys，然后选择New SSH key，将id_rsa.pub内容复制上去。在Git bash中输入“ssh -T git@github.com”，测试添加ssh是否成功。如果出现“Hi 你的用户名”，恭喜你，添加成功！ 11.在blog文件夹中找到_config.yml文件，修改repo值，注意：空格。 1234deploy： type: git repository: git@github.com:maliao/maliao.github.io.git branch: master 12.搭建完成，执行hexo new post “博客名”新建一篇博客，（发布文章之前使用npm install hexo-deployer-git –save命令安装一个必要拓展）通过编辑器编辑好文章后，执行hexo d -g命令，你的第一篇博客便发出了。 搭建过程中的一些坑1.Node.js在安装的过程中会自动配置环境。 2.官网下载Git非常慢，可以选择其他方式。 3安装Hexo的过程很慢，而且可能会停在某处，不要试图去打扰他，静静地等待就好了。 4.本地访问Hexo时候，Ctrl+C和你平时用的复制键是一个，所以要注意，不要复制了网址，Hexo却stop了。 5.在你测试添加ssh是否成功的时候，她可能出现一个很迷的选项让你选择（YES/NO）,跟教程不太一样，这时候，你要果断选择YES。 6.新版本Git，配置Deployment时候，不要试图去修改type后的git为github。 7.再次部署文章的时候，记得先使用“hexo clean”命令，不然你会体会到什么叫佛。]]></content>
      <categories>
        <category>博客杂谈</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
